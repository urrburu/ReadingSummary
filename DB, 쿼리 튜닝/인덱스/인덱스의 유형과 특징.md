인덱스란? 인덱스는 말 그대로 전체 중 특정한 부분을 바로 찾을 수 있는 목차나 색인의 개념임

# 1. B-tree 인덱스
관계형 데이터베이스에서 가장 일반적으로 사용되는 인덱스라고 할 수 있음 
하나의 노드에 여러 자료가 배치되는 트리구조

### 1.1 B-tree 인덱스의 구조 
 - 인덱스는 루트블록과 브랜치불록, 리프 블록으로 구성
 
브랜치 블록은 여러 레벨을 가질 수 있다. 리프 블록이 증가하면서 분할이 발생하면 브랜치 블록이 추가된다. 계속된 증가로 브랜치 블록이 분할되면 다시 상위의 브랜치 블록이 만들어진다. 우리가 인덱스를 경유하여 데이터를 액세스 할 때 루트 블록에서 출발해서 브랜치 블록을 추적해 리프 블록을 찾은다. 유일 스캔이면 바로 테이블을 액세스하고 멈추지만 범위 스캔일 때는 리프 블록을 계속해서 스캔한다. 

범위 스캔시 처리할때 나타나는 사항

- 인덱스는 구성컬럼들과 RowID로 정렬되어 있다. RowID에는 물리적인 파일정보를 비롯하여 로우가 저장된 블록의 주소, 로우의 슬롯 번호가 기록되어있다.
- 처리할 범위의 첫 번째 인덱스 로우를 브랜치 블록을 통해 리프 블록을 액세스한 다음 거기에 있는 RowID로 블록을 찾는다. SGA영역(시스템 글로벌 영역)부터 찾아보고 없으면 디스크에서 액세스한다.
- 새롭게 액세스한 데이터 블록 정보는 PGA(프로그램 글로벌 영역) 영역으로 가져와서 해당 SQL의 처리 버퍼에 넣는다. 
- 인덱스 블록을 액세스한 내용을 PGA버퍼에서 찾아 다른 조건까지 검증하여 성공한 로우만 운반단위로 보낸다. 만약 클러스터링 팩터가 좋다면 여러건의 인덱스 스탠을 이 버퍼와의 비교만으로 처리가능하다. 운반단위의 크기는 정의된 ARRAYSIZE나 배열패치를 했다면 바인드 변수에 지정된 배열의 크기로 정해진다. 인덱스 슽캔을 위한 버퍼의 크기도 여기에 준한다.
- 이 버퍼에서 찾을 수 없다면 다시 블록을 액세스하여 여기에 담고, 다시 매치되는 로우을 찾아 다른 조건을 검증하여 성공한 로우를 운반단위로 보낸다. 
- 리프 블록에서 액세스한 로우가 처리 범위를 넘으며 처리를 종료한다.




### 1.2 B-tree 인덱스의 조작

-   인덱스를 생성할 때 일어나는 내부적인 현상과 새로운 데이터 입력 시 발생하는 분할, 삭제, 갱신으로 인한 변화 및 스캔을 할 때 일어나는 내용을 알아 봄

(가) 인덱스 생성 
 - 테이블을 액세스하여 정렬 수행 만약 정렬의 결과가 정렬영역의 크기를 초과하면 임시 테이블스페이스에서 정렬이 수행된다. 
 - 정렬된 결과를 인덱스 세그먼트의 리프 블록 기록하기 시작한다. 인덱스 블록이 PCTFREE에 도달하기 전 까지는 자신이 브랜치 블록의 역할도 겸한다. 
 - 만약  리프 블록이 PCTFREE에 도달하여 새로운 블록을 요구하게 된다면 브랜치 블록을 구성하여 블록 헤더에 기존 블록의 DBA를 기록해둔다. 

(나) 인덱스 분할 - 인덱스는 정렬되어야 한다는 점 때문에 이미 생성된 구조에 새로운 로우가 삽입되면 기존의 위치에 파고 들어가야 하는 문제가 발생

1.  PCTFREE에 도달한 인덱스 블록에 마지막 값이 입력되면 구조에 영향을 미치지 않고 새로운 블록을 만들고 거기에 등록
2.  중간 값이 입력되면 PCTFREE가 초과하므로 분할이 발생
3.  두 블록 모두 수정되어야 하므로 2/3만 채우도록 하면서 양쪽을 모두 새로 재편
4.  이 이유는 또 다른 로우가 입력될 경우 분할이 계속 발생하는 것을 방지 하기 위함
5.  중간에 로우가 입력된 경우 2/3만 채우게 되므로 만약 이렇게 분할이 발생하고 그 블록에 값이 들어오지 않는다면 저장공간이 크게 늘어날 소지도 있음. 이를 교정하는 방법은 인덱스를 재생성(Rebuild)하는 방법뿐임


(다) 데이터의 삭제 및 갱신

-   데이터를 삭제했을 때 테이블의 로우는 제거되지만 인덱스의 로우는 단지 삭제되었음을 표시하는 Flag 로표현됨. 그 자리에 인덱스 로우가 추가되지 않을 경우 저장공간의 낭비뿐 아니라 스캔해야 할 블록이 증가함
- 삽입뿐만 아니라 삭제나 갱신이 발생하더라도 언제나 저장공간을 과도하게 소비하게 되고 이에 따라 트리 구조의 깊이가 증가하게 된다. 그러므로 데이터의 처리(DML)가 많이 수행되는 테이블은 정기적으로 재생성할 필요가 있다.

(라) 인덱스를 경유한 검색

1.  루트를 찾음
2.  주어진 값보다 큰 최소값을 찾음
3.  리프 블록을 찾을 때까지 2번을 반복함
4.  리프 블록에서 값을 찾은 후 ROWID를 이용해 테이블을 액세스

## 1.3 리버스키 인덱스
리버스는 역순의 의미가 아닌 컬럼값 자체의 역순을 의미함(각 바이트의 위치를 변경)


# 2. 비트맵 인덱스

사용하는 이유! 
1. 중복을 피해 대용량 데이터의 관리 시 공간을 절약할 수 있다. 
2. B-트리가 항상 유용하지 않다. 컬럼값의 분포도가 특정 구역에 몰려있을때만 유용하다. -> 그렇기에 다양한 데이터가 있는 데이터 웨어하우스에 적합하다. 
3. Not 연산을 거쳐 OR연산을 통해 합치는 경우 비트맵이 가진 우위를 활용할 수 있다. 

비트맵 인덱스는 컴퓨터에서 사용하는 최소단위인 비트를 이용해 컬럼값을 저장하고 이를 이용하여 RowID를 자동으로 생성하는 인덱스의 한 방법이다. 비트를 직접 관리하기 때문에 저장공간이 크게 감소하고 비트별로 각종 연산을 수행함으로써 기존의 인덱스가 해결할 수 없었던 많은 문제들을 해결했다. 
 그럼에도 불구하고 여러 제한사항이 존재하기 때문에 데이터 웨어하우스에서 활용되고 있다. 이러한 제약은 주로 **생성** 과 **유지**에 소모되는 비용이며 검색 시에는 혁신적인 장점들을 갖고 있다. 특히 대용량의 데이터 처리에서는 이러한 장점이 큰 빛을 보고 있다. 
   B-tree 인덱스에서는 실제 컬럼 값을 인덱스에도 보관하고 있어야 한다. 이것은 분명한 중복이며, 특히 수행 속도를 위해 여러 컬럼들로 구성된 결합 인덱스를 많이 생성하게 됨으로써 대용량 데이터를 관리할 때는 큰 부담이었다. 
   B-트리 인덱스에서 가장 중요한 요소는 컬럼값의 분포도가 좁아야한다는 것이었다. 이 경우는 충분히 액세스 효율을 보장할 수 있지만 분포도가 넓은 경우에는 오히려 전체 테이블을 모두 액세스 하는 것보다 불리할 수도 있다. 이를 해결하기 위해 여러 컬럼들을 결합하여 인덱스를 생성해야 했다. 

비트맵 인덱스에서 액세스 비트맵 인덱스를 경유하여 테이블을 액세스할 때는 먼저 관련 비트맵을 액세스하여 AND 연산하여 조건에 맞는 것들만 색출한다. (비트마스킹 방식으로 ) B-트리 인덱스에서는 NOT연산을 사용할 수 없었는데 비트맵 인덱스에서는 사용할 수 있다. 

# 3. 함수기반 인덱스
 함수기반 인덱스의 원리는 간단하다  테이블의 컬럼들을 가공한 논리적 컬럼을 인덱스로 생성한 것일 뿐이다. 우리가 일반적으로 쿼리에서 사용하는 컬럼은 실존하는 테이블의 물리적인 컬럼만은 아니다. 개념적으로 보면 SELECT-List나 조건절에 사용하는 모든 가공된 항목도 모두 논리적인 컬럼이라 할 수 있다. 

함수기반 인덱스는 함수나 수식으로 계산된 결과에 대해 b-트리인덱스나 비트맵 인덱스를 생성할 수 있다. 여기에서 사용할 수 있는 함수는 우리가 흔기 사용하는 산술식, 사용자 지정함수, SQL의 빌트인 함수, 패키지 등이 가능하다. 
 함수 기반 인덱스는 여러가지 제약사항을 가지고 있다. 이는 사용할때 반드시 참조하면 좋다.

 - 비용기준 옵티마이저에서만 가능하다
 - 함수기반 인덱스를 생성한 후 반드시 통계정보가 필요하다. 
 - 사용자 지정 함수는 반드시 'DETERMINISTIC'으로 선언되어야 한다. 
 - QUERY_REWRITE_ENABLED 파라미터가 TRUE로 선언되어야한다.
 - QUERY_REWRITE_INTEGRITY가 TRUSTED로 선언되어야 한다. 
 - 다음의 사용자 권한을 가져야한다.
	 - 인덱스 생성 권한 :  INDEX CREATE/ANY INDEX CREATE
	 - 쿼리 재생성 권한 : QUERY REWRITE/ GLOBAL QUERY REWRITE
 - 함수나 수식의 결과가 null인 경우는 이 인덱스를 통해 유지할 수 있다.
 - 등등..... 나중에 보충할 예정

함수기반 인덱스는 마치 실제 뷰처럼 가공된 컬럼의 값을 저장하고 있다. 만약 쿼리의 셀렉트 리스트에 인덱스에 기술된 문구를 사용하였다면 인덱스에 저장된 값을 그대로 제공한다. 그렇다면 인덱스에 사용된 함수가 변경되었다면 인덱스 사용을 불허하든지 재성성을 하든지 과거의 값을 그대로 제공해야만 한다. 

이게 결론이.... 참조하는 테이블의 데이터에 변화가 발생했더라도 함수기반 인덱스에 이미 저장된 과거의 데이터값을 그대로 인정하는 방법 뿐...... 

그래도 사용하는 곳이 몇 군데 있는데, 
1. 테이블 상의 설계 문제를 해결
	1-1. 컬럼의 중간 부분의 검색
		과거에는 코드가 가장 중요하다고 여겼던 시절이 있다. 중요한 키값에 각 자리수 마다 의미를 부여해 기다란 코드를 만들어둔다. 마치 유전자를 해독하듯 애플리케이션에서는 온통 코드로 알고리즘을처리하는 사람이 많았다.이러한 관습이 아직 남아있다.
		데이터 모델링에서 컬럼을 정의할때 원자 값으로 지정해야한다는 원칙이 있다. 이 원칙을 준수하지 않은 설계는 쿼리에서 필연적으로 SUBSTR 함수를 이용하여 데이터를 처리하게 된다. 물론 인덱스와 상관이 없다면 용인될 수도 있겠지만, 만약 어떤 컬럼의 중가늬 일부를 검색 조건에 사용한다면 선행값을 조건에 부여할 수 없기 때문에 인덱스를 사용할 수 없게 되거나 불필요한 범위를 액세스 해야 한다. 
		이러한 경우에 일부분만을 별도의 함수기반 인덱스로 생성하거나 자주 결합되어 사용되는 다른 컬럼과 결합한 인덱스를 생성함으로써 문제를 어느정도 해소시킬 수 있다.
	1-2. 조인 연결고리 컬럼이 대응하지 않는 경우의 해결
	
	1-3. 일자 컬럼이 분할된 경우의 해결
	
	1-4. 데이터 타입이 상이한 조인 컬럼
	
2. 가공처리 결과의 검색
	2-1. 복잡한 계산 결과의 검색
	
	2-2. 말일, 단가, 율의 검색
	
	2-3. 기간, 컬럼 길이 검색
	
	2-4. 오브젝트 타입의 인덱스 검색
		
3. 오류데이터의 검색 문제를 해결

4. 오브젝트 타입의 인덱스 검색

5. 배타적 관계의 인덱스 검색


에 사용된다. 

# 4. B+ 트리 인덱스

모든 leaf node는 연결리스트로 연결되어 있습니다. -> B-트리 인덱스에서 B+인덱스로 현대 DB가 사용하는 인덱스를 바꾼 중요한 이유. 순차검색에 있어서 B-트리보다 더 유리하다.
