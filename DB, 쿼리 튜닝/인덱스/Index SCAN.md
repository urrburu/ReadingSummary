이 스캔방식은 실제적으로 가장 많이 발생하는 방식이라고 할 수있다. 우리가 인덱스를 경유해서 어떤 로우를 추출할 때 결과를 보면 로우를 찾는 것이 지만 실제적으로 내부적인 I/O는 언제나 블록을 액세스한다. 메모리로 액세스 된 블록의 헤더정보를 참조하여 해당 로우를 식별한다. 따라서 옵티마이저가 비용을 산정할 때 도 역시 로우가 아니라 블록을 기준으로 계산을 하게 된다. 

만약 극단적인 가정으로 하나의 블록에 하나의 로우가 들어 있다면 액세스해야하는 로우 수와 블록 수는 같아지게 된다. 그러나 우리가 찾고자 하는 로우들이 몇개의 블록 내에 잘 모여 있다면 훨씬 적은 블록을 액세스 할 수 있다는 것이다. 이것을 다른 말로 표현하자면 운송단가와 유사한 의미라고 할 수 있을 것이다. 이 개념을 **클러스터링 팩터** 라고 부른다. 하나의 테이블은 여러개의 인덱스를 가질 수 있다 . 이미 한번 저장되어 있는 테이블은 필요에 따라 저장형태를 변경할 수는 없기 떄문에 인덱스의 컬럼 값에 따라 클러스터링 팩터는 차이가 난다. 
 이것은 중요한 개념이다. 동일한 테이블을 모체로 모시고는 있지만, 인덱스에 따라 클러스터링 팩터는 크게 달라질 수 있다는 것은 액세스 효율과 관련된 이야기다. 인덱스는 구성컬럼의 값으로 정렬되어 있기에 그 정렬 형태가 테이블에 저장된 로우와 얼마나 유사하게 저장되어 있는냐에 따라 클러스터링 팩터는 달라진다. 
# 클러스터링 팩터

 - 낮다면 -> 소수의 블록에 데이터가 밀집 되었음을 의미함
 - 높다면 -> 다수의 블록에 데이터가 산재되어 있음을 의미함
이를 더 세부적인 부분으로 나눠서 이해할 필요가 있다. 

## 인덱스 유일 스캔

이 스캔은 대부분 단 하나의 ROWID를 추출하는 것을 목표로 한다. 이러한 스캔을 위해서는 인덱스가 기본키나 유일 인덱스로 생성되어있어야 하며, 여기에 구성된 모든 컬럼들이 모두 조건절에서 '=' 연산자로 비교되어야 가능하다. 
 만약 이를 충족하지 못한다면 유일 값으로 구성된 인덱스라고 할지라도 범위스캔이 들어갈 수 밖에 없다. 이 스캔으로 유도하는 힌트가 있긴 하지만, 대부분의 경우는 특별히 힌트를 부여할 필요는 없다.
 
  옵티마이저는 만약 인덱스 유일 스캔이 가능하다면 최우선적으로 인덱스 유일 스캔을 선택하게 되어있다. 
가능하지 않은데도 불구하고 힌트를 부여했다면 그 힌트를 무시할 것이다. 

하지만 데이터 베이스 링크를 사용했을때 유일 인덱스의 사용이 가능함에도 불구하고 옵티마이저가 이를 선택하지 못하는 경우가 있다. 이 경우에는 힌트를 이용해 이를 바로 잡을 수 있다. 원격에 있는 테이블을 액세스하거나 테이블이 너무 작아서 옵티마이저가 전체 테이블 스캔으로 결정을 해버릴 경우가 있을 때 힌트를 줘서 이 스캔으로 바로잡을 수 있다. 힌트는 별도로 있는 것이 아니라 특정 인덱스 사용을 권고하는 INDEX(table alias index name)을 적용한다. 
 

## 인덱스 범위 스캔
인덱스 범위 스탠은 가장 보편적인 형태의 데이터 액세스이다. 이것은 시작과 종료를 의갸ㅏ진 경우와 하나 이상이 끝을 가지지 않은 경우가 있다.

이 스캔을 경유하여 추출되는 로우는 인덱스 구성 컬럼의 정렬 순서와 동일하게 나타난다. 만약 여러분이 쿼리에서 ORDER BY 를 했더라도 옵티마이저는 사용 인덱스의 정렬 순서에 따라 추가적인 정렬 작업을 하지 않을 수 있다. 

인덱스 범위스캔은 최초의 시작점을 찾을 때만 랜덤 엑세스를 사용하고 그 다음부터 종료시 까지는 스캔을 한다. 좀더 정확하게 표현한다면 브랜치 블록을 경유하여 시작 리프 블록을 찾은 후 계속해서 연결된 다음 리프 블록을 스캔하다가 종료점을 만나면 멈춘다. 
 인덱스 블록은 상대적으로 테이블 블록에 비하면 적은 양이며 연속된 블록을 액세스하므로 상당히 낮은 운송단가를 가졌다. 범위가 넓어짐에 따라 부하가 증가함는 것은 인덱스 스캔 탓이 아니라 인덱스의 ROWID 로 테이블을 랜덤 액세스 해야하는 높은 운송단가를 가진 액세스가 증가하기 때문이다. 그러므로 만약 인덱스로 액세스 되는 ㄴ테이블의 로우들이 유사하게 모여 있다면 이러한 부하는 현격하게 감소할 수 있다. 이것이 앞서 언급한 클러스터링 팩터이다. 
  옵티마이저가 인덱스를 범위 스캔할 수 있는 경우는 하나 이상의 인덱스 선행 컬럼에 상수나 변수로 조건이 부여 되어 있어야 한다. 비교연산자 "-, <, >, >=, <=, BETWEEN, LIKE"등이 가능하다. 단 LIKE 연산자의 경우는 비교값의 선두에 "%ABC"의 형태로 와일드 카드가 있으면 인덱스 범위 스캔을 할 수 없다. 

 인덱스 범위 스캔은 유일 인덱스나 비유일 인덱스 모두에서 발생할 수 있다. 인데스를 사용할 수 있음에도 불구하고 전체 테이블 스캔하는 실행 계획에서나 원하는 다른 인덱스를 사용하도록 하기 위해 INDEX(table_alias index_name) 힌트를 사용할 수 있다. 

## 인덱스 역순 범위 스캔

인덱스 역순 범위 스캔은 역순으로 데이터 를 액세스한다는 것을 제외한다면 인덱스 범위 스캔과 동일하다. 인덱스는 기본적으로 순차적으로 정렬되어 저장된다. 이 스캔은 스캔의 시작점은 최대값이 되고 역순으로 리프 블록을 스캔하여 최소값이 될 때까지 스캔한다. 

 현실세계에서는 지속적으로 데이터가 발생하기 때문에 가장 최근에 발상한 내용을 먼저 보기를 원하는 경우가 많이 있다. 이런 경우의 대부분은 과거에 발생한 데이터에 대한 범위를 제한하지 않는 경우가 많아 탐색할 범위가 매우 넓다. 만약 이렇게 넓은 범위를 순차적으로 범위 스캔하여 역순으로 정렬을 해야 한다면 많은 부하가 발생하게 될 것이다. 

 이러한 경우 인덱스를 역순으로 스캔해 정렬을 생략할 수 있다면 매우 효율적인 처리가 가능하다. 이러한 부분을 보다 체계적으로 활용하는 방법은 [부분범위처리에 관하여] 글을 읽으면 된다. 이 스탠이 발생하는 이유는 쿼리에서 ORDRE BY .... DESC 를 할때 옵티마이저의 판단에 의해 일어나거나 인덱스 범위 스캔을 하는 실행계획에 힌트를 적용해줄때 나타나게 된다. 힌트는 INDEX_DESC(table_alias index_name)을 사용한다. 



## 인덱스 스킵 스캔
이 스캔방식은 기존의 인덱스 사용 원칙을 바꾸어놓은 중요한 스캔방식이다. 기존에는 인덱스의 선행 칼럼이 사용되지 않으면 무조건 인덱스 스캔이 불가능했다. 이 인덱스 범위 스캔은 최초의 시작 리프 블록을 찾아갈 때만, 브랜치 블록을 사용하고 이후에는 계속해서 끝날 때까지 리프 블록을 스캔해간다. 
 결합 인덱스의 앞부분에 있는 컬럼들이 무조건 모두 브랜치 블록에 속한다고는 할 수 없지만 브랜치 블록의 속성상 상위의 카디널리티 낮은 컬럼들의 값들로 브랜치 블록이 구성되어 있을 수 있는 것은 충분 가능한 일이다. 예를 들어 세개의 컬럼 COL1, COL2, COL3을 연결시켜 하나의 새 칼럼으로 만들어 인덱스를 만들었다고 생각해볼때, 
  만약 선행칼럼인 col1이 높은 카디널리티를 갖고 있고 col2와 col3이 아주 낮은 카디널리티를 갖고 있다고 했을 때 브랜치 블록은 col1의 앞자리 값들로 구성될 것이다. 그러나 반대의 경우를 보면, col1, col2는 아주 카디널리티가 낮고 col3가 높다면 브랜치블록의 상당부분은 col1, col2가 차지할 것이다. 
   이러한 브랜치 블록의 정보들을 논리적인 개념에서 일종의 서브 인덱스(인덱스를 찾는 인덱스)라는 의미로 이해할 수가 있겠다. 인덱스 스킵 스캔은 선행 컬럼이 사용되지 않더라도 상위의 각각의 분기된 가지 별로 주어진 조건 컬럼을 스캔해낸다. 

*옵티마이저는 쉽게 인덱스 스킵 스캔을 선택하려 하지 않는다. 왜냐하면 인덱스 스킵 스캔은 서브 인덱스의 종류가 많지 않고, 뒤에 오는 컬럼은 많을 때 최적의 효과를 내는데 이러한 경우를 제외하면 원하는 만큼의 효과를 얻을 수 없다. 즉 아주 특정한 경우에만 힘을 발휘하는 인덱스라는 것이다. 이를 제외하면 인덱스가 구성되어있는 경우, 직접조건을 부여한 경우에 비해 효과적이지 못하다.*

  이 스캔방식을 사용하되 너무 의존해서는 안된다. 이 기능을 너무 과신해서 선행컬럼이 잘 사용되지 않는 인덱스를 함부로 만드는 것은 좋은 생각이 아니다. 뿐만 아니라 잘 사용되지 않는 칼럼이 중간에 들어있거나  = 이 아닌 연산자를 사용하는 컬럼을 앞에 위치시키는 것도 좋은 선택은 아니다. 인데스 수립 전략을 참고하도록 하자. 


## 인덱스 전체 스캔
인덱스 전체 스캔은 조건절에서 그 인덱스의 컬럼이 적어도 하나 이상 사용되었을 때 적용이 가능하다. 즉 반드시 선행 컬럼이 사용되어야 할 필요는 없다는 것이다. 만약 다음과 같은 둑가지 조건을 모두 만족한다면, 조건절에 전혀 사용된 컬럼이 없어도 적용가능하다.

 - 쿼리 내에 사용된 어떤 테이블의 모든 컬럼들이 그 인덱스에 모두 존재하고
 - 인데스 컬럼 중에서 최소한 NOT NULL 인 컬럼이 하나는 존재할 때

이러한 경우는 테이블을 대신하여 사용될 수 있다. 만약 NOTNULL인 컬럼이 하나도 없다면 최악의 경우 어떤 인덱스 로우는 모두 NULL 값을 가지게 되어 인덱스에 저장되지 않을 수 있기 때문에 전체 테이블과 로우 수가 달라지므로 테이블을 대신할 수 없다. 

가령 "select( * ) from user_table"을 수행시켰을 때 많은 블록을 가진 테이블을 액세스하지 않고, 최소한 하나 이상의 NOTNULL컬럼을 가진 소량의 블록을 가진 엊떤 인덱스를 전체 스캔하여 결과를 구할 수 있다. 이 밖에도 만약 어떤 쿼리에서 ORDER BY를 하려는 요구를 어떤 인덱스를 사용함으로써 가능하다면 이 스캔을 사용할 수 있다. 

## 인덱스 고속 전체 스캔
만약 쿼리를 위해 사용된 어떤 테이블의 컬럼이 모두 그 인덱스에 포함되어 있다면 인덱스 고속 전체 스캔은 전체 테이블 스캔의 대안으로 사용할 수 있다. 단 NOTNULL제약 조건이 정의된 컬럼이 인덱스에 반드시 하나 이상 존재해야한다. 그 이유는 앞서 말한 것과 동일하다. 
 이 스캔은 인덱스 만을 스캔할 뿐이지 테이블을 액세스하러 가지 않는다. 특기할 사항은 앞서 설명한 인덱스 전체 스캔과는 다르게 마치 테이블 액세스처럼 한번의 I/O에 다중블록을 액세스한다는 것이다. 물론 병렬처리를 사용할 수도 있기 때문에 인덱스 전체 스캔이나 테이블 전체 스캔에 비해 훨씬 빠르다. 그러나 이 스캔 방식은 비트맵 인덱스에서는 적용할 수 없다. 
이 방식은 INDEX(table_alias index_name)힌트를 사용해 필요하다면 이 스캔으로 유도할 수 있고, NO_INDEX(table_alias index_name) 힌트로 해제할 수 있다. 
