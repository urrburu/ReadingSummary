# 1) Semi Join의  개념 및 특징
세미조인이라는 말은  원래 분산질의를 효율적으로 수행하기 위하여 도입된 개념이다. 두 테이블 간에 조인을 할때 한 테이블을 다른 사이트에 전송하기 전에 먼저 조인에 필요한 속성만을 추출하는 프로젝션을 실시하여 전송한 후, 조인에 성공한 로우의  집함만을 다시 전송함으로써 네트워크를 통해 전송되는 데이터의  양을 줄이고자 하는 개념으로 도입된 것이다. 여기서 세미조인은 주로 서브쿼리를 사용했을 때 메인쿼리와의 연결을 하기위해 적용되는 광범위한 유사조인을 의미한다. 


- 서브쿼리와 메인 쿼리 중 무엇이 먼저 수행하는가? -> 상황에 따라 달라진다......

세미조인은 Nested Loops조인방식과 Sorted Merge 조인 형식으로 모두 수행할 수 있다. 

 - 그렇다면 서브쿼리는 표현 방법만 다를 뿐이지 조인과 같은가? -> 아니오

조인과 서브쿼리는 매우 유사해 보이지만 본질적인 차이는 집합간의 종속성에 있다. 어떤 집합들을 연결하고자 할때 조인은 동일한 등급상에 유치하지만 서브쿼리는 주종관계를 갖게 된다. 동일한 등급이냐 아니냐는 그들간에 교환법칙이 성립하냐 하느냐에 있다고 할 수도 있다. 서로간에 위치를 바꾸어도 동일한 결과를 얻을 수 있다면 동등관계 그렇지 않다면, 종속관계에 있다는 것을 의미한다. 이 차이는 연산결과와 상속여부에 영향을 미치게 될 것이다. 

큰 특징중의 하나로 조인과정에서 등장한 컬럼들을 사용할 수 있는 상속성에 대한 부분이 있다. 조인은 조인된 집합에 있는 모든 컬럼들을 아무런 제약없이 사용할 수 있지만 세미조인은 그렇지 못하다. 메인쿼리에는 서브쿼리의 집합에 있는 컬럼들을 사용할 수 없다. 서브쿼리는 역으로 메인쿼리의 집합에 있는 컬럼들을 마음대로 쓸 수 있다. 

# 2) 세미조인의 실행계획
## 가) Nested loops형 세미조인
<어떤 집합이 수행되어 거기서 얻은 상수값을 연결고리를 통해 대응 시키는 조인 방법>
'제공자'의 역할을 하냐, '확인자'의 역할을 하냐의 문제. 
제공자일 경우 -> 서브쿼리가 먼저 수행 -> 메인 쿼리 연결고리에 대응시킴
확인자 -> 메인쿼리 수행 이후 서브쿼리의 연결고리에 제공 

- 제공자일때 
세미조인이 절대적으로 준수해야하는 철칙인 메인쿼리 집합의 보호를 위해서 SORT(UNIQUE)를 하는 단계가 추가로 삽입되어 있음을 알 수 있음 제공할 키2의 상수값을 유니크하게 만들었으므로 이게 1:1 조인이 되어 일반적인 조인 형식으로 처리되더라도 메인쿼리의 집합은 보존된다. 

물론 서브쿼리에서 연결고리의 상수값으로 제공할 컬럼이 해당 테이블의 기본키로 제공되어 있다면, 옵티마이저는 서브쿼리의 수행 결과가 M집합이 아니라는 것을 알기 때문에 위의 그림에서와 같이 유니크를 만드는 처리는 생략된다. 이러한 경우의 실행계획은 일반적인 조인 시와 동일하다. 

 - 확인자일때
 제공자일 때와 큰 차이가 없다. 다만 중요한 것은 FILTER의 존재이다. 
 이 방식의 조인은 기존의 네스티드 루프 조인과 동일한 방법으로 진행하되 대응하는 결과집합 전체를 대상으로 하지 않고 대응하는 첫번째 까지만 연결하는 조인방식이다. 이 방식은 먼저 수행되는 집합에서 처리하는 각각에 대해 언제나 단 하나씩과 연결을 하게 되므로 결코 메인 쿼리의 집합에 훼손을 가져오지 않는다. 

이때 생각해야하는 것은 매우 커다란 차이가 여기 존재하는다는 것이다. 서브쿼리 내에 메인 쿼리의 컬럼이 존재한다는 것은 곧 종속성을 의미한다. 이 서브쿼리는 논리적으로 절대 먼저 수행될 수 없도록 종속되었다는 것이다. 

## 나) Sorted Merge형 세미조인
## 다)해쉬형 세미조인