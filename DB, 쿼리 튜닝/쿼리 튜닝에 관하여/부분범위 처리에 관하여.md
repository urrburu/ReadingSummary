# 부분범위 처리 vs 전체범위 처리
 전체범위 처리 -> 전체범위 스캔 -> 조건 체크 -> 임시저장 ->2차가공 -> 운반단위 만큼 패치

vs

 부분범위 처리 -> 운반단위를 채울때 까지만 스캔 -> 스캔하면서 조건처리를 해 운반단위에 넣음 -> 스캔이 끝난 인덱스를 기억하면 됨


이러한 처리 방식의 차이는 운반단위에 옮겨지기 전에 일어나므로 우리 눈에 잘 보이지 않는다. 다시 말해서 액세스를 정확히 볼 수 있는 눈이 없으면 알 수가 없다는 것이다. 실행계획을 통해 액세스 경로를 확인해보면 쉽게 알 수 있다. 전체범위 처리를 나타내는 항목은 많이 있으나, 그 중에서도 """*실행계획에서 SORT* """가 들어있다면 해당 그룹은 전체범위 처리를 하고 있다고 생각하면 된다.
여기에서 '해당 그룹' 이라는 말은 실행계획의 계층구조를 두고 한 말이다. 

### 다시 말해서 SORT로 표현된 것부터 하위에 있는 단계는 모두 전체범위가 된다는 것을 말한다. 주의할 것은 SORT가 있다고 해서 전체 SQL이 모두 전체범위를 처리하는 것은 아니라는 것을 명심할 것. 


Sort는 실행계획에서 다양한 형태로 나타난다. Sort(unique), sort(join), sort(aggregate), sort(order by), sort(group by) 등으로 나타난다.  이 외에도 실행계획에 VIEW 라고만 나타나 있는 단계는 처리를 하는 중에 내부적으로 임시 저장공간에 쓰기 작업을 하였다는 뜻이기 때문에 전체범위처리를 한다고 보면 된다. 

착각하기 쉬운 부분 중 하나가, SQL은 부분범위 처리를 하고 있지만, SQL을 실행시킨 툴이 '일단정지'를 시키는 툴이 없다면 계속해서 처리범위가 끝날때까지 결과를 요구함으로써 마치 전체범위를 처리하는 것처럼 보일 수도 있다는 것에 유의할 필요가 있다. 사용하는 툴에 따라서 일단멈춤의 기본값이 OFF 상태로 되어 있는 것은 ON으로 반드시 고쳐주어야만 한다. 
 그렇기에 툴이 부분범위처리를 할 수 이쓴지 시험해보는 것은 중요한다. 가장 쉬운 방법은 대량의 데이터를 갖고 있는 테이블을 WHERE 절 없이 수행시켜 보는 것이다. 만약 결과가 즉시 추출된다면 부분범위 처리를 하고 있다는 것이며 한참 기다려야 한다면 전체범위 처리를 하고 있다는 것이다. 멈춤기능이 OFF 상태이기에 그럴 수도 있다. 


### 1) 부분범위 처리의 적용원칙
 전체범위로 처리된 SQL이 부분범위 처리로 바뀌면 상당한 수행속도 향상을 노려볼 수 있다. 모든 경우의 처리를 부분범위 처리로 수행할 수는 없기 때문에 부분범위 처리로 수행되기 위한 필수 조건을 이해하는 것과 그렇게 처리되도록 유도하는 방법을 아는 것은 매우 중요하다. 

 1-1) 자격 
 부분범위 처리를 할 수 있는 자격 = 논리적으로 보았을때 전체범위를 읽어서 가공을 해야하는 경우를 제외한 모든 형태

 - 따라서 UNION, MINUS, INTERSECT를 사용한 SQL은 부분범위로 처리할 수 없다. 집합연산은 그 결과가 반드시 유일(Unique, Distinct)해야 하기 때문이다. 
-> 여기에서 속도이슈와 관련된 중요한 부분이 나오는데 차집합을 구하는 연산에서 SQL이 부분범위로 처리될 때 EXISTS 나 IN을 이용한 서브쿼리 세미조인 방법이 있다. 그러나 EXISTS 세미조인도 경우에 따라서는 Sorted Merge 조인 방식으로 처리되므로 항상 부분범위 처리가 되는 것은 아니다. 
 - 여기에서 판단의 기준이 나온다. 대부분의 서브쿼리 연산과 조인 연산은 조인연산이 우위에 선다. 성능상으로 여러개의 SQL이 날아가는 상황과 하나의 SQL만이 날아가는 상황은 하나쪽을 들어줄 수 밖에 없다. 
 - 옵티마이저를 여기서 고려하게 된다면 한번 더 여기서 생각이 들어간다. 세미조인 서브쿼리의 경우는 부분범위 처리로 연산을 진행하기에 빠를 수도 있다. 하지만 전체 범위를 검토해서 서브쿼리의 조건이 만들어질 경우, 다시 조인연산이 빠르게 된다. 
- 그렇기에 여기서 한번 더 생각할 수 있다. 조인을 해야만 하는 경우 anti조인을 사용한다면 Exists 나 IN 조건처럼 부분범위처리를 받을 수 있다. 

1-2)옵티마이저 모드에 따른 부분범위처리

주어진 SQL이 논리적으로 부분범위 처리를 할 수 있다고 하더라도 옵티마이저의 모드에 따라 차이가 날 수 있다. 규칙기준이냐 비용기준의  FIRST_ROWS로 지정되어 있는 경우에는 대개의 경우 부분범위 처리를 하지만, 비용기준의 ALL_ROWS로 지정되어 있다면 전체범위 처리를 하는 경우가 많이 나타난다. 이 SQL은 앞서 부분범위 처리를 할 수 없도록 하는 함수를 ㅓ사용하지 않았으므로 논리적으로 볼때 부분범위 처리가 가능하다. 그러나 이 SQL을 수행하는 옵티마이저 목표가 ALL_ROWS라면 실행계획 수립에서 차이가 난다. 
 통계정보에 따라서 차이가 있겠지만, 비록 ORD_DEPT를 선두 컬럼으로 하는 인덱스가 있더라도 손익분기점을 초과한다면 옵티마이저는 인덱스를 사용하지 않고 전체테이블을 스캔하는 실행계획을 수립한다. 즉, 실행계획이 달라질 수 있다. 

따라서 룰기반의 ALL_ROWS와 FIRST_ROWS 옵티마이저 모드를 의식하고 이런 부분을 만들어야 한다. 대부분은 비용기준 옵티마이저나 FIRST_ROWS가 유리하다. 

### 2) 부분범위처리의 수행속도 향상원리
일반적인 상식으로 좁은범위의 처리가 넓은 범위의 처리보다 빠를 수 밖에 없다. 그러나 부분범위로 처리되면 경우에 따라서 오히려 넓은 범위를 갖는 경우가 더 빨라지는 것을 경험하게 된다. 

Select * 의 단순한 문장을 수행할 경우 몇백만건의 로우를 갖더라도  0.01 초 내에 연산이 끝난다. 이 SQL에는 Where절이 없다. 조건이 없다는 것은 무조건이므로 이 테이블의 첫번째 블록을 스캔한 모든 로우들을 그대로 운반단위로 보내서 바로 추출시키는 부분범위처리를 한다. 

여기에 Order by 한절만 들어가더라도 수행시간은 크게 달라진다. 옵티마이저를 잘 모른다면 정렬처리가 왜 이렇게 느린지에 대해서 의문을 갖게 된다. 단순히 이것은 정렬작업 때문만은 아니다. 

첫번째 실행시킨 SQL은 부분범위 처리를 했기에 실제로 수행한 일은 한 운반단위 만큼만 처리하고 멈추었다. 

두번째는 전체범위를 처리해야 하기 때문에 전체 테이블을 모두 액세스하여 임시 저장공간에 저장하고 정렬 시킨 후 하나의 운반단위를 추출하고 멈추었다. 

정렬은 생각보다 매우 빠르다 1000로우에 0.1초가 걸리지 않는다. 수행속도를 늦게 한 주된 이유는 정렬작업 + 전체범위처리가 필요했기 때문이다. 만약 ITEM을 첫번째로 하는 인덱스가 있다는 것을 전제로 했을때, WHERE절에 ITEM과 관련된 조건을 검사한다면 이는 인덱스를 이용해 부분범위 처리로 들어간다. 
-> 그렇기에 인덱스는 ITEM의 값으로 정렬되어 있으므로 굳이 ORDER BY ITEM을 하지 않았더라도 동일한 결과를 낼 수 있으며 이는 현격한 차이가 난다. 

1)) 액세스를 주관하는 컬럼의 처리범위는 좁을수록 유리하다. 이러한 경우는 나머지 컬럼들의 처리범위에 영향을 적게 받는다. 즉 언제나 빠른 수행속도를 보장받을 수 있다.

2)) 액세스를 주관하는 컬럼의 범위가 넓어지더라도 그 외의 조건을 만족하는 범위가 넓다면 역시 빠른 수행속도를 보장받을 수 있다. *그러나 조건들이 좁은 범위를 갖는다면 오히려 늦어진다.*

3)) 액세스 주관 컬럼의 범위가 넓고 그외 컬럼의 범위가 좁아서 늦어지는 경우는 처리범위가 좁은 컬럼이 액세스 주관 컬럼이 되도록 하면 해결된다. 대개의 경우, 옵티마이저는 주어진 조건에 따라 항상 좁은 처리 범위를 가진 컬럼을 사용하도록 실행계획을 수립한다. 그러나 옵티마이저 모드나 비교된 컬럼의 분포도에 따라, 작성된 SQL에 따라 그렇지 못한 경우가 발생할 수 있다. 

++ 힌트나 사용제한 기능을 사용해 옵티마이저를 도와주면 우리가 원하는 수행속도를 얻을 수 있다. 어떤 인덱스를 사용하는 실행계획이 수립되었을때, 오히려 ORDNO 인덱스를 사용할 수 없도록 사용을 제한해 해결할 수 있다. 
주관조건은 최대한 좁게! 검증조건은 넓게! 성립하지 않는다면 교체

