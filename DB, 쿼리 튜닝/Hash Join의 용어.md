데이터처리 범위가 날이 갈수록 초대형으로 증가하면서 이제 많은 부분에서 Sort Merge가 더 이상의 대안이 될 수 없는 지경에 지르렀다. 이에대한 해결책이 요구되었고 이것이 Hash Join이다. 대용량 처리의 선결조건인 랜덤과 정렬에 대한 부담을 해결할 수 있는 대안으로서 등장하게 되었다. 


- 해쉬영역
- 해쉬영역이란 해쉬조인을 수행하기 위해 메모리 내에 만들어진 영역을 말한다. 이 영역은 비트맵 벡터와 해쉬테이블, 그리고 파티션 테이블 영역으로 구성되어 있다. 비트맵 벡터는 먼저 액세스하는 빌드입력의 유일한 값을 생성해 두었다가 나중에 검색하는 검색입력을 필터링하는데 사용한다.
- 해쉬테이블에는 파티션들의 위치정보를 가지고 있으면서, 조인의 연결작업을 수행할때나 디스크에 내려가 있는 파티션 짝들을 찾는데 사용된다. 파티션테이블에는 여러개의 파티션이 존재하며 조인할 집합의 실제 로우들을 가지고 있는 영역이다. 
- 해쉬영역이 부족하면 디스크를 사용할 수 밖에 없어 수행속도에 지대한 영향을 미치게 되므로 해쉬영역크기를 적절하게 지정하는 것은 매우 중요하다. 
- 파티션
- 파티션이란 파티션을 결정하기 위해 수행하는 첫번째 해쉬 함수가 리턴한 동일한 해쉬값을 갖는 묶음을 말한다. 즉, 동일한 해쉬값을 가진 로우들의 버켓을 말한다. 특히 빌드입력이 인-메모리에서 작업이 불가능하면 반드시 파티션으로 나뉘어져야 한다. 이렇게 만들어진 파티션 수를 팬아웃 이라 부른다.
- 하나의 파티션은 여러개의 클러스터로 분리된다. 2차해싱을 하면 저장할 클러스터의 위치가 졀정되며, 이 단위는 I/O의 단위가 될 뿐만 아니라 검색의 단위로도 활용된다. 파티션 수를 많게 하면 - 즉, 팬아웃을 크게 하면 - 적은 크기의 많은 파티션들이 생성되기 때문에 비효율적인 I/O가 발생할 수 있다. 반대로 너무 적게 하면 , 지나치게 큰 파티션이 생성되어, 해쉬영역과 맞지 않을 수도 있으므로 이에 대한 결정은 해쉬조인의 효율에 큰 영향을 미친다. 
- 클러스터
- 파티션은 작지 않은 크기로 되어 있기에 이를 다시 클러스터 단위로 분할한다. 이 클러스터는 연속된 블록으로 되어 있으며 디스크와 I/O를 하는 단위가 된다. 물론 주어진 파라미터 에 의해 동시에 I/O하는 양이 결정된다. 
- 여기서 말하는 클러스터는 오라클의 클러스터링 테이블을 적용할때 나타나는 클러스터와 개념적으로는 유사한 면이 있다. 특히 해쉬 클러스터링을 했을 때와 매우 유사한 형태로 이해하는 것이 좋다. 해쉬 클러스터링을 했을 때는 해쉬함수에서 생성된 값이 같으므로 동일한 클러스터에 저장되고 이를 검색할 때는 해쉬값으로 해당 클러스터를 찾아 클러스터를 스캔하면서 원하는 로우를 찾는다. 해쉬조인에서는 이와 매우 유사하게 해쉬테이블을 만들어 해당 클러스터를 찾고 클러스터를 스캔하여 원하는 로우와 연결하게 된다. 
- 이 클러스터를 슬롯이라고도 부르며, 마치 캐비닛을 파티션이라고 한다면 슬롯은 서랍이라고 생각하면 이해가 빠를 것이다. 우리가 물건을 찾을때도 먼저 캐비싯을 결정하고 서랍을 열러서 물건을 꺼내는 것과 비슷하다. 
- 빌드입력과 검색입력
- 조인을 위해 먼저 액세스하여 필요한 준비를 해두는 처리를 빌드 입력이라 하며, 나중에 액세스하면서 조인을 수행하는 처리를 검증, 혹은 검색입력이라고 한다. 조인대상집합이 이 중에서 어느 역할을 담당했느냐에 따라서 처리 방법이나 수행속도에 많은 차이가 날 수 있다. 
- 물론 그 원인과 원리는 상세한 내부 처리 절차를 언급하면서 설명하기로 한다. 파티션이란 조인 연결고리 에 대해 동일한 해쉬 값을 갖는 묶음이라고 정의할 수 있다. 동일한 파티션에 위치하게 된다는 것은 나중에 구체적인 연결을 하는 연결처리 단위가 된다는 것을 의미한다. 
- 인메모리 해쉬 조인과 유예 해쉬조인
- 해쉬조인 에서는 전체 빌드입력이 해쉬영역보다 적은 경우와 그ㅎ지 않은 경우로 나뉨 그러므로 무조건 적은 집합을 가진 것이 빌드입력이 되도록 해야함.
- 그러나 실전에서 아무리 적은 집합을 선택하고 해쉬영역을 크게 한다고 해도, 대량의 처리를 하게 되면 반드시 한계가 있기 마련이다. 빌드입력이 해쉬영역에 모두 위치할 수 있는 경우는 인메모리 해쉬조인을 수행하게 되고 그렇지 못한 경우에는 유예 해쉬조인을 수행하게 된다. 
- 유예 해쉬조인은 먼저 전체를 빌드입력과 검색입력을 수행하여 여러개의 파티션에 분할하고, 해쉬영역을 초과할때마다 임시세그먼트에 파티션을 저장한다. 해쉬 함수를 이용하여 파티션하게 되면 각 조인대상이 동일한 파티션에 위치하는 것이 보장되므로 각 파티션 별로 다시 빌드입력과 검색입력이 동적으로 결정되어 보다 효율적인 연결작업을 수행하게 된다. 
- 비트맵 벡터
- 해쉬조인을 이해하기 위해서는 또 한 가지 중요한 개념을 알고 있어야 한다. 그것은 바로 비트맵 벡터라는 것이다. 이것은 빌드 입력에 대해 파티션을 구하는 작업 중에 생성되며, 빌드 입력값들에 대한 파티션을 구하는 작업 중에 생성되며, 빌드입력값들에 대한 유일한 것을 메모리 내의 해쉬영역에 정의하는 것을 말한다. 이 값들은 장차 검색입력의 파티션 생성작업 시에 필터링을 하는데 사용된다.
- 해쉬영역에 만들어지는 비트맵 벡터는 빌드입력의 전체집합에 대해서 생성된다. 즉, 처리대상이 커서 해쉬영역을 초과하여 임시 세그먼트에 저장하게 되더라도 처리할 빌드입력의 모든 집합에 대해 조인종료시까지 유지한다.
-  검색입력에서 액세스한 것이 어차피 빌드입력에 존재하지 않는다면, 굳이 파티션에 위치시킬 필요조차 없기 때문에 이를 필터링 하는 중요한 역할을 하게된다. 이 작업은 파티션을 결정하기 위해 해쉬함수를 적용하기 전에 수행하여 불필요한 대상들을 걸러내므로 실제 조인에 참여할 대상을 경우에 따라 크게 줄일 수 있다. 일반적으로 이 영역은 메모리에 정의하는 해쉬영역의 5%로 생성된다
- 해쉬 테이블
- 이번에는 해쉬 테이블에 대해서 알아보자. 이 테이블은 메모리 내에 만들어지며 최종적으로 조인의 연결작업에서 대응되는 로우를 찾기 위한 해쉬 인덱스로 사용된다. 마치 Nested Loops 조인에서 나중에 대응되는 로우르 ㄹ인덱스에서 찾는 것과 유사하지만 물리적인 인덱스가 미리 생성되는 것이 아니라 조인을 수행할때 임시적으로 생성된다는 것이 다르다. 물론 그 인덱스 구조는 해싱을 활용하는 방법이다. 
- 일반 인덱스에서 인덱스 컬럼값과 ROWID를 가지고 있는 것과 유사하게 해쉬테이블은 해쉬키값과 해쉬 클러스터의 주소를 갖고 있다. 일반적인 인덱스는 테이블의 로우만큼의 인덱스 로우를 가지고 있지만 해쉬 테이블에는 실제 테이블의 로우 별로 인덱스를 가지고 있지는 않는다. 이는 마치 해쉬 클러스터링 테이블에서 해쉬 클러스터로 액세스하는 것과 유사한 개념이다. 
- 데이터가 각 파티션에 해쉬 클러스터 개념으로 저장되어 있으므로 연결 작업을 시도할 때 검색입력에 있는 연결고리 값으로 해쉬키 값을 찾고 거기에 있는 클러스터 주소를 이용해 해당 클러스터를 찾아 스캔하면서 연결을 수행한다. 
- 기본기로 연결하는 것에 비해 부담이 된다고 생각할 수 있겠지만, 전혀 그렇지 않다. 일반적인 인덱스 연결은 최악의 경우, 하나의 연결을 위해 한 블록이 액세스 될 수도 있다. 그러나 해쉬 조인의 연결에서는 파티션 짝들 간에는 연결에 필요한 데이터가 100% 존재하는 것이 보장되기 때문에, 메모리 내에서 해쉬를 적용하여 수행하는 연결은 일반적인 랜덤과는 비교할 수 없이 빠르다. 
- 파티션 테이블
- 만약 빌드입력이 메모리 크기를 초과하여 파티션을 생성하게 되면, 파티션 테이블에 관련정보가 저장된다. 또한 디스크의 임시 세그먼트로 이동하면 그 위치정보를 갖는다. 이 위치정보는 나중에 다시 메모리로 올려서 처리할 대상을 선정할 때 활용된다. 또한 빌드입력과 검색입력에서 생성된 파티션 간에 서로 짝을 찾는데도 활용된다. 
-  임시 세그먼트에 있는 파티션들을 어떻게 묶어서 처리할 것이냐는 조인 효율에 상당한 영향을 미치게 된다. 물론 우리는 그 알고리즘까지 알 필요는 없다. 그러나 같은 묶음으로 처리되는 단위마다 파티션들의 크기의 합이 적은 집합을 빌드입력으로 적용하고 나머지는 검색입력의 역할을 하게 된다.
- 그러므로 처리되는 단위마다 동적으로 역할이 변할 수 있으며 이것을 일컬어 동적역할반전이라고 부른다. 이러한 개념을 적용하는 이유는 인-메모리 해쉬 조인의 가능성을 높이기 위한 전략 때문이다.
- 비트맵 벡터나 파티션 테ㅔ이블은 설사 처리량이 인 메모리를 초과하더라도 전체 집합에 대한 정보를 가지고 있지만, 해쉬 테이블은 해당 처리단위의 빌드입력에 대해서만 정보를 가지고 있다는 것에 차이가 있다. 해쉬테이블은 해당 처리단위의 연결작업을 위한 인덱스 개념으로 사용되지만 다른 두가지는 전체 작업에 필요한 정보를 가지고 있기 때문이다. 이들의 합이 전체 해쉬영역의 15~20%를 넘으면 오버헤드가 발생하므로 이런 경우에는 해쉬영역을 증가시키는 것이 바람직하다.
- 통계정보에 있는 히스토 그램을 이용하여 파티션의 크기나 파티션 내의 데이터 분포를 동적으로 관리하며 이 결과를 다음번 수행시에 활용하여 파티션의 크기를 결정하기도 한다. 물론 이러한 기능은 DBMS나 버전에 따라 차이가 있다. 