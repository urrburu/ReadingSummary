빌드입력이 해쉬영역을 초과하면 해쉬 조인은 좀더 복잡한 과정을 거치게 된다. 그 이유는 빌드입력이 해쉬 영역을 초과하게 되면 어쩔 수 없이 디스크를 이용할 수 밖에 없다. 만약 억지로 인메모리 처럼 처리하고자 함ㄴ다면 검색입력이 조인을 시도할 때마다 최악의 경우는 디스크에 있는 것들을 계속해서 메모리로 옮겨야 하기 때문에 도저히 감당할 수 없다. 
 이처럼 빌드입력의 일부라도 디스크에 저장을 할 수 밖에 없다면, 마치 정렬을 통해 연결하는 Sort Merge 조인처럼 무엇인가 정렬과 유사한 효과를 얻을 수 있는 방법이 있어야 한다. 정렬을 하지 않고서도 연결이 가능하도록 데이터를 위치시키는 방법은 바로 해쉬함수를 적용하는 것이다. 
 SOrt Merge 조인은 각각의 집합을 먼저 정렬을 한 수 , 그것을 머지하는 방식으로 연결을 수행한다. 해쉬조인은 각각의 집합에 대해 먼저 해쉬함수를 적용하여 같은 해쉬값을 갖는 파티션에 저장한 후 그들의 짝을 찾아 연결을 수행한다. 
 1) 통계정보를 참조하여 보다 효과적인 카디널리티를 갖는 집합을 빌드입력으로 선택한다. 
 2) 파티션 수를 경정한다
 3) 빌드입력의 조인키에 대하여 1차 해쉬함수를 적용하여 저장할 파티션을 결정한다. 
 4) 2차 해쉬함수를 적용하여 해쉬값을 생성한다.
 5) 이 값을 이용하여 해쉬 테이블을 만들고, 해당 파티션의 슬롯에 저장한다. 이때 저장되는 컬럼은 SQL의 SELECT- List에 있는 컬럼들도 같이 저장된다. 
 6) 검색입력의 필터링을 위해 사용할 비트맵 벡터를 생성한다. 여기서 생성된 겂을 이용해 다름에 수행될 검색입력의 필터링을 하게 되므로 유예 해쉬조인에서도 크기가 작은 비합이 빌드입력이 되는 것이 조인할 대상을 보다 효과적으로 줄일 수 있다. 여기까지는 인-메모리 해쉬 조인과 거의 유사하다. 
 7) 이러한 방식으로 빌드입력의 처리 범위를 처리하다가 해쉬영역을 초과하면 파티션 테이블에 위치정보를 남기고 디스크로 이동하게 된다. 파티션 테이블에 있는 정보는 나중에 파티션 짝을 찾아 연결작업을 수행할 때 사용된다. 
 8)  빌드입력의 모든 처리범위를 위의 방법으로 끝까지 수행한다. 
 9) 이번에는 검색입력의 처리범위를 액세스하기 시작하여 조건을 만족하지 않으면 버리고, 만족한 것들은 1차 해쉬함수를 적용해 비트맵벡터를 필터링한다. 비트맵 벡터에서 찾을 수 없다면 해당 건의 처리는 종료되고 다음 검색입력 대상으로 넘어간다. 
 10) 필터링을 통과한 것은 2차 해쉬함수를 적용한다. 만약 이때 검색입력에 대응되는 빌드입려깅 메모리 내에 존재하면 해쉬 테이블을 읽어 연결을 수행하고 그렇지 않으면 해당 파티션에 저장한다. 
 11)  연결을 수행할 수 없는 파티션들을 디스크에 저장한다. 
 12) 이러한 작업을 검색입력의 모든 처리범위에 대해 반복 수행한다. 
 13) 처리되지 않은 파티션들을 처리하기 위해 파티션 테이블의 정보를 이용하여 파티션 짝들을 디스크에서 메모리로 이동시킨다. 
 14) 새로 메모리로 이동한 집합 중에서 크기가 작은 집합으로 해쉬 테이블을 생성한다. 즉 처리할 파티션 짝들을 모았을 때 그 크기에 따라서 빌드입력과 검색입력이 다시 결정된다. 
 15) 그러므로 경우에 따라서 최초에 결정되었던 빌드입력과 검색입력의 역할이 바뀔 수 있다. 
 16) 검색입력으로 결던된 집합을 스캔하면서 해쉬테이블을 이용하여 연결을 수행한다. 물론 운반단위에 모았다가 채워지면 리턴하는 것은 당연하다. 이 작업을 모든 대상에게 실시한다. 


## 2) 유예조인의 특징과 처리기준
가장 먼저 꼽을 수 있는 특징 : 이 방식 또한 조인의 연결을 위해서 기존에 미리 생성되어 있는 인덱스를 전혀 사용하지 않는다는 것이다. 이는 조인 연결고리에 인덱스가 없어도 영향을 받지 않는 다는 것, 그러면서도 오히려 기존의 B-Tree 인덱스 보다 더 유리한 해쉬를 이용한 조인을 할 수 있다는 것이 자랑이다. 
 특히 대량의 데이터를 처리하는 경우는 대개 배치처리인 경우가 많다. 또한 이러한 처리는 재료의 역할을 하는 집합을 다양하게 연결하여, 필요하다면 인라인뷰를 이용한 중간집합을 만들어 가면서 집합의 연산을 통해 결과집합을 생성해 가는 방식으로 접근할 수가 있다. 이러한 집합의 연산과정은 이미 가공된 집할일 수 있기 때문에 인덱스가 존재하지 않을 수도 있음은 물론이고, 대개의 경우 대용량의 처리이기 때문에 데이터량의 증가에 따른 부담이 최소화 될 필요가 있다. 
  위의 처리결과에서 나타났듯이 해쉬조인은 비록 해쉬영역을 초과하는 대용량의 데이터라 하더라도 해쉬함수를 이용하여 적절한 위치에 옮겨 두었다가 조인 대상들을 다시 불러들여 해쉬 테이블을 통해 조인을 수행하므로 Sort Merge 조인이 갖는 최대의 약점인 대용량 데이터의 정렬에 대한 오버헤드를 해결하는 최적의 수단이라고 할 수 있다. 
   또한 선행처리된 집합이 만든 비트맵 벡터를 이용하여 나중에 처리되는 집합을 조인전에 미리 필터링을 할 수 있으므로 Nested Loops 조인의 장점의 일부까지 수용하고 있다. 그러므로 먼저 수행되는 집합이 어느 것인지 활용할 필요가 있다. 물론 옵티마이져가 옳은 판단을 하는 경우도 많이 있지만 잘못된 판단도 많으므로 대용량의 처리에 서는 이러한 것을 주의하는 것 만으로도 때로는 대단한 수행속도 향상을 가져올 수 있다는 점을 명심하기 바람.
    유예해쉬조인으로 수행되면 인메모리 해쉬조인과 달리 부분범위 처리가 불가능하게 된다는 사실은 경우에 따라 조인 방식을 결정하는 매우 중요한 기준이 되기도 한다. 우리는 부분범위로 처리될 수만 있다면 조인하는 양쪽 집합이 아무리 커도 아주 빠르게 처음운반단위가 리턴된다는 것을 알고 있다. 물론 단지 일부분이 먼저 리턴되는 속도가 빠를 뿐이다. 전체 범위를 그렇지 않을 수도 있으니 처리하는 어플리케이션에 따라 판단을 잘 해야 할 것이다. 



 - 실전에서 해쉬조인으로 인해 나쁜 영향을 미치는 대부분의 경우는 옵티마이저가 전체범위 처리에 최적효율을 위해 최적화를 하게 되어 기존에 부분범위 처리를 하는 것들을 전체범위 처리로 바뀌었기 때문에 발생하는 경우가 대부분이다. 아무리 해쉬조인이 유리하다고 하더라도 대량의 전체범위를 모두 처리하고 결과를 리턴하는 것은 일부분만 처리하고 바로 결과를 리턴하는 것보다 빠를 수는 없다. 
 
 - 또한 대용량의 데이터를 조인한다면 상당히 큰 해쉬 영역을 필요로하므로 수많은 프로세스가 공동으로 사용하는 귀중한 메모리를 함부로 차지한다는 것은 시스템 전체 시각에서 볼때는 커다란 오버헤드가 될 수 있다는 것을 잊어서는 안된다. 그러므로 온라인 처리에서 함부로 해쉬조인을 처리하는 것은 문제를 발생시킬 소지가 충분하다. 적은 크기의 해쉬영역으로 인메모리 해쉬조인이 가능하다면 별개의 문제이다. 
 - 이번에는 Sort Merge 조인과 적용기준의 차이를 살펴보자면, 대용량의 처리라면 해쉬와 소트머지 조인이 메모리에 지정하는 크기가 커야한다는 점은 다르지 않기 때문에, 이에 대한 부담은 유사하다. 그러나 처리할 조인량이 이 영역을 크게 초과할 수 밖에 없는 경우라면 효율의 차이는 매우 크게 나타난다. 
 -  데이터량이 커질 수록 이 효율의 격차가 크게 벌어지는데 물론 해쉬조인이 당연히 유리하다. 이 말은 곧 초대형 조인에서는 해쉬조인을 사용해야만 한다는 것을 의미하기도 한다. 
 - 하지만 해쉬조인은 엄격히 말해 더 많은 메모리 영역을 사용하게 된다. 이 말은 단위작업이 아닌 시스템 전체의 자원을 관리하는 측면에서 볼때, 중요한 의미를 가진다. 이 두가지 조인은 소량의 조인일 때는 거의 차이가 없다. 그러나 조인량이 증가할 수록 차이가 나타나다가 어느 시점을 이후로 커다란 차이가 된다. 
 - 실전에서는 일반적으로 정렬영역의 1.5배 정도를 해쉬영역으로 지정하여 사용한다. 이것은 그만큼의 자원부담이 있음을 나타낸다. 가장 좋은 방법은 임의의 프로세스가 함부로 자원을 지나치게 할당받지 못하게 하기위해 대용량의 처리를 하는 경우는 해당 프로세스에서 영역의 크기를 적절하게 다시 지정하게 하는 것이 좋은 전략이다. 
 - 소트머지와 해쉬조인이 큰 차이가 나지 않는 경우라면 해쉬조인은 추가적인 정렬작업이 필요할 수도 있기에 그것을 감안해서 결정해야한다는 점을 명심하자. 