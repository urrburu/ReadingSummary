데이터처리 범위가 날이 갈수록 초대형으로 증가하면서 이제 많은 부분에서 Sort Merge가 더 이상의 대안이 될 수 없는 지경에 지르렀다. 이에대한 해결책이 요구되었고 이것이 Hash Join이다. 대용량 처리의 선결조건인 랜덤과 정렬에 대한 부담을 해결할 수 있는 대안으로서 등장하게 되었다. 

### 1) Hash Join의 원리(랜덤과 정렬의 부담에서 벗어날 수 있는)

- 해쉬영역
- 해쉬영역이란 해쉬조인을 수행하기 위해 메모리 내에 만들어진 영역을 말한다. 이 영역은 비트맵 벡터와 해쉬테이블, 그리고 파티션 테이블 영역으로 구성되어 있다. 비트맵 벡터는 먼저 액세스하는 빌드입력의 유일한 값을 생성해 두었다가 나중에 검색하는 검색입력을 필터링하는데 사용한다.
- 해쉬테이블에는 파티션들의 위치정보를 가지고 있으면서, 조인의 연결작업을 수행할때나 디스크에 내려가 있는 파티션 짝들을 찾는데 사용된다. 파티션테이블에는 여러개의 파티션이 존재하며 조인할 집합의 실제 로우들을 가지고 있는 영역이다. 
-  해쉬영역이 부족하면 디스크를 사용할 수 밖에 없어 수행속도에 지대한 영향을 미치게 되므로 해쉬영역크기를 적절하게 지정하는 것은 매우 중요하다. 
- 파티션
- 파티션이란 파티션을 결정하기 위해 수행하는 첫번째 해쉬 함수가 리턴한 동일한 해쉬값을 갖는 묶음을 말한다. 즉, 동일한 해쉬값을 가진 로우들의 버켓을 말한다. 특히 빌드입력이 인-메모리에서 작업이 불가능하면 반드시 파티션으로 나뉘어져야 한다. 이렇게 만들어진 파티션 수를 팬아웃 이라 부른다.
- 하나의 파티션은 여러개의 클러스터로 분리된다. 2차해싱을 하면 저장할 클러스터의 위치가 졀정되며, 이 단위는 I/O의 단위가 될 뿐만 아니라 검색의 단위로도 활용된다. 파티션 수를 많게 하면 - 즉, 팬아웃을 크게 하면 - 적은 크기의 많은 파티션들이 생성되기 때문에 비효율적인 I/O가 발생할 수 있다. 반대로 너무 적게 하면 , 지나치게 큰 파티션이 생성되어, 해쉬영역과 맞지 않을 수도 있으므로 이에 대한 결정은 해쉬조인의 효율에 큰 영향을 미친다. 
- 클러스터
- 파티션은 작지 않은 크기로 되어 있기에 이를 다시 클러스터 단위로 분할한다. 이 클러스터는 연속된 블록으로 되어 있으며 디스크와 I/O를 하는 단위가 된다. 물론 주어진 파라미터 에 의해 동시에 I/O하는 양이 결정된다. 
- 여기서 말하는 클러스터는 오라클의 클러스터링 테이블을 적용할때 나타나는 클러스터와 개념적으로는 유사한 면이 있다. 특히 해쉬 클러스터링을 했을 때와 매우 유사한 형태로 이해하는 것이 좋다. 해쉬 클러스터링을 했을 때는 해쉬함수에서 생성된 값이 같으므로 동일한 클러스터에 저장되고 이를 검색할 때는 해쉬값으로 해당 클러스터를 찾아 클러스터를 스캔하면서 원하는 로우를 찾는다. 해쉬조인에서는 이와 매우 유사하게 해쉬테이블을 만들어 해당 클러스터를 찾고 클러스터를 스캔하여 원하는 로우와 연결하게 된다. 
-  이 클러스터를 슬롯이라고도 부르며, 마치 캐비닛을 파티션이라고 한다면 슬롯은 서랍이라고 생각하면 이해가 빠를 것이다. 우리가 물건을 찾을때도 먼저 캐비싯을 결정하고 서랍을 열러서 물건을 꺼내는 것과 비슷하다. 
- 빌드입력과 검색입력
- 조인을 위해 먼저 액세스하여 필요한 준비를 해두는 처리를 빌드 입력이라 하며, 나중에 액세스하면서 조인을 수행하는 처리를 검증, 혹은 검색입력이라고 한다. 조인대상집합이 이 중에서 어느 역할을 담당했느냐에 따라서 처리 방법이나 수행속도에 많은 차이가 날 수 있다. 
-  물론 그 원인과 원리는 상세한 내부 처리 절차를 언급하면서 설명하기로 한다. 파티션이란 조인 연결고리 에 대해 동일한 해쉬 값을 갖는 묶음이라고 정의할 수 있다. 동일한 파티션에 위치하게 된다는 것은 나중에 구체적인 연결을 하는 연결처리 단위가 된다는 것을 의미한다. 
- 인메모리 해쉬 조인과 유예 해쉬조인