## 1) 인메모리 해쉬 조인
인 메모리 해쉬 조인은 빌드입력을 모두 메모리에 저장하고 해쉬 테이블을 만들어 검색입력을 스캔하면서 조인을 수행한다. 비록 모양상으로는 랜덤이지만, 거의 부담이 없는 랜덤을 수행하기 때문에, Sort Merge 조인처럼 연결을 위해 정렬을 해야하거나 Nested Loops 조인처럼 수많은 블록을 액세스하지 않아도 되므로 대용량 데이터의 조인에 매우 효과적일 수 있다. 
- 뿐만 아니라 Nested Loops 조인만이 가질 수 있는 부분범위 처리도 가능하게 되므로 만약 어느 한쪽의 처리 범위가 크지 않는 경우라면 매우 효율적인 조인 방법이라고 할 수 있다. 
1) 통계정보를 참조하여 보다 효과적인 카디널치티를 갖는 집합을 빌드입력으로 선택한다. 일반적으로 조인은 1:1이나 1:M관계에서 발생하므로 대부분의 경우 1쪽이 빌드입력이 된다
2) 팬아웃, 즉 파티션 수를 결정한다. 파티션의 수와 크기는 성은에 큰 영향을 미치게 되므로 히스토그램 정보에 입각하여 이를 동적으로 최적화하여 결정하게 된다. 
3) 빌드입력의 조인 키에 대하여 1차 해쉬함수를 적용하여 저장할 파티션을 결정한다. 
4) 2차 해시함수를 적용하여 해시값을 생성한다. 
5) 이 값을 ㅣ용ㅇ해 해쉬 테이블을 만들고, 해당 파티션의 슬롯에 저장한다. 이때 저장되는 칼럼은 SQL의 SELECT-List에 있는 컬럼들도 같이 저장된다. 즉 쿼리를 위해 사용될 컬럼들만 저장된다. 
6) 검색입력의 필터링을 위해 사용할 비트맵 벡터를 생성한다. 이 값은 유일한 겂으로 만들어지므로 처리할 값을 찾아본 후 없으면 생성하고 있으면 그대로 통과하는 방식으로 생성된다. 
7) 이러한 방식으로 빌드입력의 처리 범위를 모두 처리할 때까지 반복적으로 수행한다. 
8) 이번에는 검색입력의 처리범위를 액세스 하기 시작하여 조건을 만족하지 않으면 버리고 그렇지 않으면 다음을 실행한다.
9) 첫 번째 해쉬함수를 적용해 비트맵 벡터를 필터링한다. 물론 여기에서 찾을 수 없다면 해당 처리는 종료되고, 다음 검색입력 대상으로 넘어간다. 
10) 필터링을 통과한 것들은 2차 해쉬함수를 적용함여 해쉬테이블을 읽고 해당 파티션을 찾아 슬롯에서 대응 로우를 찾는다
11) 조인이 되면 SELECT-List에 기술된 로우을 완성하여 운반단위로 보낸다. 
12) 이러한 작업을 반복해 계속 운반단위를 채운다.
13) 정해진 운반단위가 다 채워지면 리턴한다. 여기서 알 수 있듯, 비록 빌드입력은 전체범위를 모두 처리했지만 검색입력은 운반단위가 채워지면 먼저 리턴할 수 있으므로 부분적으로나마 부분범위 처리가 가능해진다. 그러나 실제로는 일반적으로 빌드입력은 크지 않으므로 거의 Nested Loops  조인과 유사한 부분범위 처리가 가능하다고 할 수 있다.
14) 이러한 방식으로 검색입력의 처리범위가 끝날 때까지 반복해서 수행한다.


## 2) 인메모리 해쉬조인의 특징과 적용기준

조인의 연결을 위해, 기존에 미리 생성되어 있는 인덱스를 전혀 사용하지 않는다. 이는 조인 견결고리에 인덱스가 없어도 영향을 받지 낳는다는 것, 그러면서 오히려 기존의 B-Tree 인덱스보다 오히려 더 유리한 해쉬를 이용한 조인을 할 수 있다는 것이 장점이다. 
대부분간 테이블간에 단순 조인에서는 이미 연결고리에 인덱스를 가지고 있을 것이므로 이런 장점이 크게 부각되지는 않지만, 만약 인라인 뷰에서 GROUP BY 등을 통해 가공한 집합과 조인을 하는 경우라면 가치가 상승한다. 

조인은 단순히 필요한 집합을 찾아오는 과정이 아니다. 집합의 연산을 이용함으로써 대부분의 처리를 SQL을 이용해 실현하고자 한다. 이러한 방식은 처리하고자 하는 내용이 훨씬 단순화 되어 나타나고, 최적화가 쉬워 생산성과 품질 향상에 매우 유리하다. 물론 이러한 능력을 가지게 되기 까지는 많은 노력이 필요하겠지만, 여기에 숙달되고 매혹된 사람은 접근방식이 차원을 달리한다. 

이처럼 집합의 연산을 하다보면 중간에 생성되는 집합들은 일종의 임시테이블이라고 할 수 있다. 당연히 이들은 인덱스를 가질 수 없다. 또한 이런 처리의 대부분은 대량의 처리범위를 수행하는 경우이므로 수행속도도 부담된다. 이러한 처리에서 해쉬 조인이 가져주는 가치가 크다. 

인-메모리 해쉬 조인이 가능하다면 이제 더 이상 울며겨자먹기로 Nested Loops 조인을 수행하지 않아도 된다. 이전까지는 부분범위 처리를 할려면 랜덤의 부담이 큰 Nested Loops 조인을 어쩔 수 없이 선택했지만, 이제는 사정이 달라졌다.
 메모리는 여러 프로세스들이 공동으로 사용하는 영역이어서 너무 크게 적용할 수는 없기 때문에 모든 것을 인-메모리 해쉬 조인에 맡기려 하는 것은 옳지 못하다. 즉 Nested Loops 조인으로도 확실한 효율과 수행속도를 보장받을 수 있다면 지나친 해쉬조인은 하지 않는 것이 좋다. 

-> 이 때에는 처리 범위가 기준이 될 것이다. 드라이빙 테이블이 충분히 적어야 해쉬조인의 장점이 제대로 발휘된다. 

