가장 전통적인 방법. 가장 보편적으로 사용되는 조인 방식. 조인방식의 결정에서는 이 방식으로 수행해도 문제가 없는지 보고, 문제가 있다고 판단될때 다른 대안을 생각해봐야할 정도로 가장 기본이 되는 조인방식이다. 
 이 조인방식은 엑세스한 결과를 다음 액세스에 상수값으로 제공해줄 수 있는 특징이 있다. 먼저 처리한 결과가 범위를 아주 적게 줄여주었다면 다음 처리할 집합이 이를 이를 활용할 수 있어야한다. 이러지 못하면 효율이 매우 떨어진다. 
  실세계에서 발생하는 대부분의 처리는 자신이 원하는 특정한 영역을 처리하고자 하는 것이 일반적이다. 
그 중에서도 특정 영역 = 소량의 처리를 의미한다. 그렇기에 실세계에서 대부분의 조인은 네스티드 루프 조인을 사용하고 이를 면밀히 이해할 수 있어야한다. 

# 1. 기본개념
1) 먼저 탭1의 FLD1 인덱스를 경유하여 FLD1 = '111'인 처리범위 중 첫번째 로우를 액세스 한다.
2) FLD1인덱스에 있는 ROWID에 의해 TAB1의 로우를 액세스한다. 액세스된 로우의 모든 컬럼값들은 상수값이 된다. 이 상수값을 가지고 FLD2 LIKE 'AB%' 조건을 체크하여 성공한 것은 다음으로 진행하고 실패하면 1)로 돌아가서 다음 건으로 다시 처리를 시도한다.
3) 여기서 성공한 것들에 대해 TAB1의 KEY1의 상수값을 이용하여 TAB2의 KEY2 인덱스로 대응되는 인덱스로우를 찾는다. 물론 여기서도 대응되는 로우가 없다면 실패가 되어 1)로 돌아간다. 
4) KEY2 인덱스에 있는 ROWID에 의해 TAB2의 로우를 액세스한다. 이때 만약 KEY2 + COL1로 인덱스가 구성되어 있다면 이 단계에서 COL1 = '10'조건을 체크하고 그렇지 않으면 다음 단계로 넘어간다. 물론 액세스된 TAB2의 모든 컬럼 값들은 상수값이 된다. 
5) COL1 = '10'의 확인을 위해 테이블에서 추출된 상수값을 가지고 비교하여 조건을 만족하면 최종적인 결과를 운반단위로 보낸다. 
6) 이렇게 한 사이클이 돌았다면 다시 FLD1인덱스의 두번째 로우를 읽어 위의 작업을 반복한다. 만약 부분범위 처리가 가능하다면 운반단위가 채워질 때까지만 수행되고 일단 멈출 것이며, 전체범위 처리라면 FLD1 범위가 끝날 때까지 계속(Nested) 반복(Loop)처리한다.

# 2. 특징
1) 순차적으로 처리된다. 선행테이블의 처리범위에 있는 각각의 로우들이 순차적으로 수행될 뿐만 아니라 테이블 간의 연결도 순차적이다. - 순차적 
2) 먼저 액세스되는 테이블의 처리범위에 의해 처리량이 결정된다. 즉 선행하는 집합의 처리범위가 처리하는 전체 량을 결정한다.  - 선행적
3) 나중에 처리되는 테이블은 앞서 처리된 값을 받아 액세스된다. 즉, 자신에게 주어진 상수값만으로 범위를 줄이는 것이 아니라 이미 가지고 있던 상수값과 제공받은 상수값을 합쳐서 그 중 가장 유리한 방법으로 연결이 진행된다.  - 종속적
4) 주로 랜덤액세스 방식으로 처리된다. 선행 테이블의 인덱스를 액세스하는 방법은 첫 번째 로우만 랜덤액세스이고 나머지는 스캔이다. 그러나 연결작업은 모두 랜덤액세스로 수행한다. - 랜덤액세스
5) 주어진 조건에 있는 모든 컬럼들이 인덱스를 가지고 있더라도 모두가 사용되는 것은 아니다. 연결되는 방향에 따라 사용되는 인덱스들이 전혀 달라질 수 있다. - 선택적
6) 연결고리가 되는 인덱스에 의해 연결작업이 수행되므로 연결고리 상태가 중요하다. 연결고리의 인덱스 유무에 따라 액세스 방향 및 수행 속도에 많은 차이가 발생한다.  - 연결고리상태, 방향성
7) 부분범위 처리가 가능하다. 선행하는 집합의 하나씩의 로우를 대상으로 연결을 진행하기 때문에, 부분범위 처리 조건을 만족하고 있다면 운반단위가 채워지는 순간에 우선 멈출수가 있다. 물론 2차적인 가공을 해야한다면 전체점위 처리를 할 수 밖에 없다. - 부분범위 처리 가능
8) 연결 작업을 수행한 후 마지막으로 체크되는 조건은 경우에 따라서 수행속도에 미치는 영향이 달라진다. 부분범위 처리를 하는 경우에는 조건의 범위가 넓을 수록 빨리 운반단위를 채울 수 있으므로 오히려 빨라질 수 있으나, 2차 가공을 해야하는 전체범위 처리일 때는 가공해야할 대상이 많아지기에 수행속도가 나빠진다 - 체크조건의 영향력

# 3. 특징을 기반으로 추정하는 적용 기준

1) 부분범위 처리를 하는 경우에 유리해진다. 대부분의 다른 방식의 조인들은 원천적으로 부분범위 처리가 불가능해지기 때문에 부분범위로 처리하고자 한다면 이 조인 방식을 선택한다. 해쉬조인이나 세미조인 등도 특수한 경우에는 부분범위 처리를 할 수도 있다. 그러나 그것은 특별한 경우에만 가능하므로 웬만하면 NestedLoop조인이 바람직하다.
***2) 조인되는 어느 한쪽이 상대방 테이블에서 제공한 결과를 받아야만 처리범위를 줄일 수 있는 상황이라면 이 조인 방식을 선택해야한다. 이는 이 조인 방식을 적용해야하는 가장 중요한 선택요건***
스스로 할 수 없다면 남의 도움을 받아야 한다.....조인의 방식을 결정할 때 가장 먼저 살펴봐야 하는 것은 이해득실을 따져보는 일이다.  -> "자기 스스로 얼마나 처리 범위를 줄일 수 있느냐" vs "제공받았을 때 효과가 기대에 충분히 미치는지" -> 처리량을 어떻게 줄이지? 와 관련한 문제.....

3) 처리량이 *적은 경우*라면 이 경우가 무난하다. 만약 대량의 범위를 처리해야할때 이 방식은 부담이 있다. 그것은 애부 처리과정에서 많은 랜덤액세스가 발생하므로 티끌모아 태산이 된다면 부담이 되기 때문이다. 
4) 이 조인 방식은 연결고리의 인덱스를 이용하기 때문에 연결고리의 상태에 따라 매우 큰 차이가 발생한다. 연결고리에 이상이 없다면 주어진 처리 범위에 따라 최적의 조인 방향이 유연하게 선택될 수 있다. 인덱스를 구성할 때 이러한 부분이 적절하게 감안된 전략을 미리 수립하여야한다. 
5) 먼저 수행한 집합의 처리 범위의 크기와 얼마나 많은 처리 범위를 미리 줄여줄 수 있느냐가 수행속도에 많은 영향을 미친다. 이럿은 결국 각 집합의 조인되는 순서에 의해서 결정되므로 적절한 조인 순서를 찾는 것은 매우 중요하다. 
6) 부분벙위 처리를 하는 경우에는 운반단위의 크기가 수행속도에 상당한 영향을 미칠 수 있다. 운반단위가 적을 수록 빨리 운반단위를 채울 수 있으나 패치횟수에서는 불리해지는 이중성을 가지고 있다. 애플리케이션의 유형이나 사용 언어에 따라 적절한 선택이 필요하다.
7) 선행 테이블의 처리 범위가 많거나 연결 테이블의 랜덤 액세스 양이 많다면 SortMerge 조인이나 해쉬조인을 검토해야한다. 그러나 이러한 방법들은 메모리 사용을 과도하게 요구하므로 시스템 환경에 따라서 큰 부담이 되는 경우도 있다. 이럴 때는 비록 대용량의 처리를 하더라도 메모리 사용에 거의 부담이 없는 NestedLoop 조인이 오히려 유리해질 수 있다. 실전에서는 경우에 따라 이러한 상황도 종합적으로 감안해야할 필요도 있다는 점을 명심하기 바람. 

# 4. Nested Loops Join의 순서결정
이 조인은 먼저 수행된 결과가 다음에 연결할 범위에 절대적인 영향을 미치기 때문에 어떤 순서로 수행되느냐에 따라 조인의 효율이 크게 달라진다. 하나의 테이블을 액세스할 때도 선행조건이 무엇이었느냐에 따라 액세스 효율이 달라지듯이 이 조인에서도 동일한 효과가 나타난다. 
 가장 큰 영향을 미치는 것은 *선행집합*이다. 가장 먼저 수행되는 집합으로 처리범위를 얼마나 줄여줄 수 있느냐에 따라 전체적인 처리량은 크게 달라진다. 
  앞서 연결고리 상태에 따라 발생하는 현상에 대해 살펴볼 때 나타났듯이 연결고리의 상태가 정상이라면 어느 방향으로 진행하든지 연결에 대한 대가는 동일하다. 그러나 주어진 조건이나 인덱스 구성에 따라 어느쪽이 먼저 수행되느냐에 따라 연결할 범위는 달라진다. 그러므로 어느 쪽이 초기에 많은 범위를 줄여줄 수 있는지를 따져보는 것이 중요하다. 
- 단순히 어떤 테이블이 적은 로우수를 갖느냐, 조건을 붙였느냐가 중요한 것이 아니다.
- 실제로 중요한 것은 출발하는 선행집합의 조건을 건 이후의 로우수가 어떻게 구성되어있느냐가 가장 중요하다. 
- 하지만 이도 DB구성과 클러스터링과 같은 요건에 의해 충분히 다를 수 있다. 
- 다음으로 중요한 것은 조인의 성공률이다. 연결고리로 연결할때의 성공률 뿐 아니라 연결한 후에 추가로 체크하는 조건을 통과한 최종 결과까지 감안한 것을 말한다. 두개의 집합을 조인할 때는 보다 많은 처리 범위를 줄여주는 집합이 선행되는 것만 중요하지만, 세 개 이상의 테이블을 조인할 때는 각 조인 단계의 성공률은 다음 단계의 조인량을 결정하게 된다. 
- 왜냐하면 먼저 수행된 조인 작업에서 성공한 결과만 다음 조인 작업을 수행하므로 앞 단계에서 하나라도 처리해야할 로우 수를 줄여준다면 그만큼 다음에 처리해야할 대상이 줄어들기 때문이다. 
- 1:N의 관계에서 가능한 N집합은 나중에 처리될 수록 좋다. 