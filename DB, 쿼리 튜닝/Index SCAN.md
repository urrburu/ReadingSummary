이 스캔방식은 실제적으로 가장 많이 발생하는 방식이라고 할 수있다. 우리가 인덱스를 경유해서 어떤 로우를 추출할 때 결과를 보면 로우를 찾는 것이 지만 실제적으로 내부적인 I/O는 언제나 블록을 액세스한다. 메모리로 액세스 된 블록의 헤더정보를 참조하여 해당 로우를 식별한다. 따라서 옵티마이저가 비용을 산정할 때 도 역시 로우가 아니라 블록을 기준으로 계산을 하게 된다. 

만약 극단적인 가정으로 하나의 블록에 하나의 로우가 들어 있다면 액세스해야하는 로우 수와 블록 수는 같아지게 된다. 그러나 우리가 찾고자 하는 로우들이 몇개의 블록 내에 잘 모여 있다면 훨씬 적은 블록을 액세스 할 수 있다는 것이다. 이것을 다른 말로 표현하자면 운송단가와 유사한 의미라고 할 수 있을 것이다. 이 개념을 **클러스터링 팩터** 라고 부른다. 하나의 테이블은 여러개의 인덱스를 가질 수 있다 . 이미 한번 저장되어 있는 테이블은 필요에 따라 저장형태를 변경할 수는 없기 떄문에 인덱스의 컬럼 값에 따라 클러스터링 팩터는 차이가 난다. 
 이것은 중요한 개념이다. 동일한 테이블을 모체로 모시고는 있지만, 인덱스에 따라 클러스터링 팩터는 크게 달라질 수 있다는 것은 액세스 효율과 관련된 이야기다. 인덱스는 구성컬럼의 값으로 정렬되어 있기에 그 정렬 형태가 테이블에 저장된 로우와 얼마나 유사하게 저장되어 있는냐에 따라 클러스터링 팩터는 달라진다. 
# 클러스터링 팩터

 - 낮다면 -> 소수의 블록에 데이터가 밀집 되었음을 의미함
 - 높다면 -> 다수의 블록에 데이터가 산재되어 있음을 의미함
이를 더 세부적인 부분으로 나눠서 이해할 필요가 있다. 

## 인덱스 유일 스캔

이 스캔은 대부분 단 하나의 ROWID를 추출하는 것을 목표로 한다. 이러한 스캔을 위해서는 인덱스가 기본키나 유일 인덱스로 생성되어있어야 하며, 여기에 구성된 모든 컬럼들이 모두 조건절에서 '=' 연산자로 비교되어야 가능하다. 
 만약 이를 충족하지 못한다면 유일 값으로 구성된 인덱스라고 할지라도 범위스캔이 들어갈 수 밖에 없다. 이 스캔으로 유도하는 힌트가 있긴 하지만, 대부분의 경우는 특별히 힌트를 부여할 필요는 없다.
 
  옵티마이저는 만약 인덱스 유일 스캔이 가능하다면 최우선적으로 인덱스 유일 스캔을 선택하게 되어있다. 
가능하지 않은데도 불구하고 힌트를 부여했다면 그 힌트를 무시할 것이다. 

하지만 데이터 베이스 링크를 사용했을때 유일 인덱스의 사용이 가능함에도 불구하고 옵티마이저가 이를 선택하지 못하는 경우가 있다. 이 경우에는 힌트를 이용해 이를 바로 잡을 수 있다. 원격에 있는 테이블을 액세스하거나 테이블이 너무 작아서 옵티마이저가 전체 테이블 스캔으로 결정을 해버릴 경우가 있을 때 힌트를 줘서 이 스캔으로 바로잡을 수 있다. 힌트는 별도로 있는 것이 아니라 특정 인덱스 사용을 권고하는 INDEX(table alias index name)을 적용한다. 
 

## 인덱스 범위 스캔
인덱스 범위 스탠은 가장 보편적인 형태의 데이터 액세스이다. 이것은 시작과 종료를 의갸ㅏ진 경우와 하나 이상이 끝을 가지지 않은 경우가 있다.

이 스캔을 경유하여 추출되는 로우는 인덱스 구성 컬럼의 정렬 순서와 동일하게 나타난다. 만약 여러분이 쿼리에서 ORDER BY 를 했더라도 옵티마이저는 사용 인덱스의 정렬 순서에 따라 추가적인 정렬 작업을 하지 않을 수 있다. 

인덱스 범위스캔은 최초의 시작점을 찾을 때만 랜덤 엑세스를 사용하고 그 다음부터 종료시 까지는 스캔을 한다. 좀더 정확하게 표현한다면 브랜치 블록을 경유하여 시작 리프 블록을 찾은 후 계속해서 연결된 다음 리프 블록을 스캔하다가 종료점을 만나면 멈춘다. 
 인덱스 블록은 상대적으로 테이블 블록에 비하면 적은 양이며 연속된 블록을 액세스하므로 상당히 낮은 운송단가를 가졌다. 범위가 넓어짐에 따라 부하가 증가함는 것은 인덱스 스캔 탓이 아니라 인덱스의 ROWID 로 테이블을 랜덤 액세스 해야하는 높은 운송단가를 가진 액세스가 증가하기 때문이다. 그러므로 만약 인덱스로 액세스 되는 ㄴ테이블의 로우들이 유사하게 모여 있다면 이러한 부하는 현격하게 감소할 수 있다. 이것이 앞서 언급한 클러스터링 팩터이다. 
  옵티마이저가 인덱스를 범위 스캔할 수 있는 경우는 하나 이상의 인덱스 선행 컬럼에 상수나 변수로 조건이 부여 되어 있어야 한다. 비교연산자 "-, <, >, >=, <=, BETWEEN, LIKE"등이 가능하다. 단 LIKE 연산자의 경우는 비교값의 선두에 "%ABC"의 형태로 와일드 카드가 있으면 인덱스 범위 스캔을 할 수 없다. 

 인덱스 범위 스캔은 유일 인덱스나 비유일 인덱스 모두에서 발생할 수 있다. 인데스를 사용할 수 있음에도 불구하고 전체 테이블 스캔하는 실행 계획에서나 원하는 다른 인덱스를 사용하도록 하기 위해 INDEX(table_alias index_name) 힌트를 사용할 수 있다. 

## 인덱스 역순 범위 스캔

인덱스 역순 범위 스캔은 역순으로 데이터 를 액세스한다는 것을 제외한다면 인덱스 범위 스캔과 동일하다. 인덱스는 기본적으로 순차적으로 정렬되어 저장된다. 이 스캔은 스캔의 시작점은 최대값이 되고 역순으로 리프 블록을 스캔하여 최소값이 될 때까지 스캔한다. 

 현실세계에서는 지속적으로 데이터가 발생하기 때문에 가장 최근에 발상한 내용을 먼저 보기를 원하는 경우가 많이 있다. 이런 경우의 대부분은 과거에 발생한 데이터에 대한 범위를 제한하지 않는 경우가 많아 탐색할 범위가 매우 넓다. 만약 이렇게 넓은 범위를 순차적으로 범위 스캔하여 역순으로 정렬을 해야 한다면 많은 부하가 발생하게 될 것이다. 

 이러한 경우 인덱스를 역순으로 스캔해 정렬을 생략할 수 있다면 매우 효율적인 처리가 가능하다. 이러한 부분을 보다 체계적으로 활용하는 방법은 [부분범위처리에 관하여] 글을 읽으면 된다. 이 스탠이 발생하는 이유는 쿼리에서 ORDRE BY .... DESC 를 할때 옵티마이저의 판단에 의해 일어나거나 인덱스 범위 스캔을 하는 실행계획에 힌트를 적용해줄때 나타나게 된다. 힌트는 INDEX_DESC(table_alias index_name)을 사용한다. 



## 인덱스 스킵 스캔
이 스캔방식은 기존의 인덱스 사용 원칙을 바꾸어놓은 중요한 스캔방식이다. 기존에는 인덱스의 선행 칼럼이 사용되지 않으면 무조건 인덱스 스캔이 불가능했다. 


## 인덱스 전체 스캔


## 인덱스 고속 전체 스캔



## 인덱스 조인



## 비트맵 인덱스

