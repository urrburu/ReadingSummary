# 옵티마이저는 왜 쓰는가?

옵티마이저는 가장 효율적인 방법으로 SQL을 수행할 최적의 처리 경로를 생성해주는 DBMS의 핵심 엔진입니다. 컴퓨터의 두뇌가 CPU인 것처럼 DBMS의 두뇌는 옵티마이저라고 할 수 있습니다. 개발자가 SQL을 작성하고 실행하면 소프트웨어 실행파일처럼 즉시 실행되는 것이 아니라 옵티마이저(Optimizer)라는 곳에서 "이 쿼리문을 어떻게 실행시키겠다!"라는 여러 가지 실행계획을 세우게 됩니다. 이렇게 실행계획을 세운 뒤 시스템 통계정보를 활용하여 각 실행계획의 예상 비용을 산정한 후 각 실행계획을 비교해서 최고의 효율을 가지고 있는 실행계획을 판별한 후 그 실행계획에 따라 쿼리를 수행하게 되는 것입니다.


## 옵티마이저의 형태
### 규칙기준 옵티마이저
오라클 8이하의 버전에서 기본으로 설정된 옵티마이저가 바로 규칙기반 옵티마이저이다. 직관적으로 이야기하자면 실행속도가 빠른 순으로 규칙을 먼저 세워두고 우선순위가 앞서는 방법을 채택하는 것이다. 과거에는 옵티마이저의 비용을 예측하는 능력이 좋지 않아 이 방식을 사용했다. 

 1) ROWID로 1로우 엑세스  
2) 클러스터 조인에 의한 1로우 엑세스  
3) Unique HASH Cluster에 의한 1로우 엑세스  
4) Unique INDEX에 의한 1로우 엑세스  
5) CLUSTER 조인  
6) Non Unique HASH Cluster Key  
7) Non Unique Cluster Key  
8) Non Unique 결합 인덱스  
9) Non Unique 한 컬럼 인덱스  
10) 인덱스에 의한 범위 처리  
11) 인덱스에 의한 전체 범위 처리  
12) Sort Merge Join  
13) 인덱스 컬럼의 MIN, MAX 처리  
14) 인덱스 컬럼의 ORDER BY  
15) 전체 테이블 스캔

가) 규칙기준 옵티마이저의 단점

-   오브젝트에 대한 통계정보를 가지고 있지 않기 때문에 판단의 오차가 발생할 수 있음  
    **예1) 테이블 조인 시 단순히 FROM 절 뒤에 나오는 테이블의 순서대로 조인이 된다. 
    * 다음의 두 쿼리는 실행계획이 다르다.  
     - Query 1
    ```sql
    SELECT * FROM EMP e, DEPT d WHERE e.deptno = d.deptno
     ```
     - Query 2
     ```sql
    SELECT * FROM DEPT d, EMP e WHERE d.deptno = e.deptno
     ```
    예2) 분포도를 고려하지 않으므로 인덱스 선정 시 판단 착오가 있을 수 있다.  
    * RBO는 Equal(=) 연산을 Range연산보다 우위에 둔다. 분포도를 고려한다면 Range연산 쪽이 효율이 더 좋을 수도 있다. 그러나 RBO는 분포도를 알지 못한다.  
    - Query
     ```sql
    SELECT * FROM emp WHERE A='10' and B LIKE '123%'
     ```
     B like '123%' 이 A='10' 보다 분포도가 더 좋을 수가 있다. 그러나 RBO는 알지 못하므로 무조건 후자의 방법인 A='10'을 택한다. 
    

나) 규칙기준 옵티마이저의 장점

-   매우 규칙적이고 분명하여 사용자가 정확히 예측가능
-   기본적으로 우선순위에 근거한 판단과 기타 파악이 가능한 요소(FROM 절 뒤에 나오는 테이블의 순서로 Join시 Driving 테이블 선정이나 WHERE 조건에서 어떤 인덱스가 사용될 지와 같은 요소 등)들을 이용하여 사용자는 실행 계획에 대해 정확히 예측이 가능하고 제어가 가능하다
-   전략적인 인덱스를 구성할 수 있다면 이 규칙의 보편 타당성이 매우 높아짐


### 비용기준 옵티마이저
- CBO: 관계형 데이터베이스가 추구하는 이상형이며, 대부분의 관계형 데이터베이스 제품은 CBO만 보유하고 있음. 처리방법들에 대한 비용을 산정 후, 가장 적은 비용이 들어가는 처리방법을 선택함.  
- 통계정보에는 다음과 같은 많은 정보가 있다  
테이블의 로우 수, 블록 수, 블록 당 평균 로우 수, 로우의 평균 길이, 컬럼별 상수 값의 종류, 분포도, 컬럼 내 NULL 값 수, 클러스터링 팩터, 인덱스의 깊이, 최대-최소값, 리프 블록 수 등

가) 비용기준 옵티마이저의 장점

-   현실을 감안한 최적화  
    - 컬럼 내부 분포도를 고려한 실행 계획 수립. RBO에서 보았던 Equal(=) 연산이 Range 연산보다 우위에 있다는 부분이 CBO에서는 통하지 않음  
    - Histogram을 이용한 더욱 정확한 분포도 고려
-   통계정보 관리를 통한 제어
-   최악의 상황이 발생할 확률이 감소  
    - 실행 계획을 고려하지 않고 SQL문장을 짜더라도 어느 정도의 성능은 보장됨

나) 비용기준 옵티마이저의 단점

-   실행계획 예측이 곤란  
    - 테이블의 일반적인 통계 정보 뿐만 아니고 컬럼의 Histogram까지 알고 있다고 할 지라도 예측대로 실행 계획이 나오리라는 보장이 없음  
    - Bind변수를 사용하느냐 Literal 변수를 사용하느냐에 따라서도 달라질 수 있고 시스템 상태에 따라서도 달라질 수 있음.  
    - 통계 정보 갱신 전후로 다른 실행 계획을 가질 수 있으며,
-   버전에 따른 변화  
    - DBMS 버전에 따라 결과가 달라지기도 함. DBMS 업그레이드 등을 통해 바뀌어진 옵티마이저 특성 때문에 실행 계획이 바뀌어 질 수 있음. 이는 더 좋은 방향으로 갈 수 있으나, 부분범위 처리 쿼리가 전체범위 처리 쿼리로 바뀌는 등의 부작용을 일으키기도 함.  
    예) 조인 방식의 변화(Nested Loop Join -> Hash Join): DBMS 상위 버전으로 갈수록 Hash Join이 안정화 되고 옵티마이저는 Hash Join으로 해결하려는 경향이 강해짐. 이전에 Nested Loop Join으로 해결되던 쿼리가 실행 계획이 바뀌는 경우가 있음
-   실행계획 제어가 곤란: RBO때 처럼 제어하던 방법은 먹히지 않음. Hint와 같은 보조수단을 사용해야 제어 가능

라) 통계정보 관리를 위한 제언  
 - 효과적인 통계정보의 수집과 관리를 위해 DBMS_STATS 패키지 이용
 - 이 패키지에 포함된 정보로는 테이블(행의 갯수, 차지하고 있는 블록 개수, 행들이 갖고 있는 평균 길이), 컬럼(컬럼 값의 종류, 컬럼 내부 NULL 값의 분포도, 컬럼 값의 평균 길이, 컬럼 내부 데이터 분포의 추정치), 인덱스()
