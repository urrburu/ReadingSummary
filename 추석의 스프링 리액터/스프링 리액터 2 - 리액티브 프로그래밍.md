마이크로소프트가 닷넷 생태계에 만든 Reactive Extension 라이브러리가 반응형 프로그래밍의 출발점이었다. 이후 Rxjava는 JVM위에서 실행하는 리액티브 프로그래밍을 구현했다. 시간이 지남에 따라, 리액티브 스트림 표준화의 일환으로 JVM 위에서 동작하는 리액티브 라이브러리의 인터페이스 셋과 상호작용 규칙을 정의한 자바 표준이 등장했다. 이 인터페이스들은 자바9의 Flow 클래스로 통합되었다. 

리액티브 프로그래밍 패러다임은 객체 지향 언어에서 종종 옵저버 디자인 패턴의 확장으로 사용되기도 한다. 메인 리액티브 스트림 패턴을 익숙한 이터레이터 디자인 패턴과 비교해 볼 수도 있다. 리액티브 스트림을 구현한 모든 라이브러리는 Iterable-Iterator 쌍과 성격이 유사하다. 주요 차이점 중 하나는 하나는 이터레이터는 pull기반, 리액티브 스트림은 push기반이라는 것이다. 

 이터레이터를 사용한다는 것은 값에 접근하는건 전적으로 Iterable 책임이라고 하지만, 어쨌든 명령형 프로그래밍 패턴이다. 사실상 데이터 시퀀스에서 next() 아이템에 접근하는 것은 개발자에게 달려 있다. 
  리액티브 스트림에선 Publisher - Subscriber 쌍이 이를 대신한다. 또한 push 받은 데이터에 적용할 연산은 명령형이 아닌 선언형으로 표현한다. 프로그래머는 정확한 제어 흐름을 작성하는 대신 계산 논리를 표현한다.

 리액티브 스트림은 데이터를 push 하는 것 외에 에러 처리와 완료 처리도 잘 정의하고 있다. Publisher는 Subscriber에 새 값을 푸쉬할 수 있을 뿐 아니라 에러나 완료신호를 보낼 수도 있다. 에러, 완료 신호 모두 시퀀스를 종료한다. 
```
onNext x 0..N [onError|onComplete]
```
이런 방식이다.

이 접근법은 굉장히 유용하다. 값이 없거나, 하나거나, n개일 때를 모두 커버한다.

## 3.1 블록킹은 낭비가 많을 수 있다.
소프트 웨어의 성능을 끌어올리는 방법은 크게 두가지가 있다. 

 - 더 많은 스레드와 하드웨어 리소스를 사용해 병렬처리한다.
 - 현재 사용중인 리소스를 더 효율적으로 사용할 방법을 찾는다. 

자바 개발자는 보통 블로킹 코드로 프로그램을 작성한다. 성능에 병목이 생기지 않는다면 이 방법도 괜찮다. 이때까진 유사한 블로킹 코드를 실행할 스레드를 늘리면 된다. 하지만 이 방식은 리소스를 더 사용하는 쪽으로 확장하기 때문에, 레이스 컨디션이 발생하고 동시성 이슈가 발생하기 쉽다.

더 큰 문제는 블로킹은 리소스를 낭비한다는 점이다. 자세히 관찰해보면, 대기 시간이 필요한 요청을 처리하기 시작하면 스레드는 데이터를 기다리는 동안 아무 일도 하지 않는다. 
 따라서 병렬처리는 만능 해결책이 아니다. 가능한 하드웨어 리소스를 모두 사용하는게 좋지만 리소스를 낭비하는 경우는 많으며 원인을 알아내는 것은 복잡한 일이다. 
 
## 3.2 비동기가 우리에게 구원인가?
위에서 언급한 두 번째 방식대로, 리소스 효율적으로 사용할 방법을 찾는다면 리소스를 낭비하지 않을 수 있다. 비동기, 논 블로킹 코드를 작성하면 동일 리소스를 사용하는 또 하나의 활성 태스크로 실행을 전환하고, 비동기 처리를 완료하면 현재 프로세스로 돌아올 수 있다. 

 그렇다면 JVM 위에서 동작하는 비동기 코드는 두가지 방법이 있다. 자바가 지원하는 방법은


 - Callbacks : 리턴 값은 없지만 결과를 받으면 호출할 콜백 파라미터를 람다나 익명 클래스로 추가로 받는 비동기 매소드. 스윙의 EventListener 계층 구조로 잘 알려져 있다.
 - Futures 곧바로 Future<T> 를 반환하는 비동기 매소드. 비동기 프로세스는 T값을 계산하고, 이를 래핑한 Future 객체로 접근한다. 이 값은 즉시 사용할 수 있는 상태는 아니며, 사용이 가능해질 때까지 객체를 폴링할 수 있다. 예를 들어 ExecutorService 는 Callable<T> 태스크를 실행할 때 Future 객체를 사용한다. 

두 가지 방법 모두 제약이 있다. 

콜백은 조합이 까다로워 읽기도 유지보수 하기도 어려운 코드를 만드어내기 쉽다. 소위 콜백지옥이라고 이를 부른다. 
예를 들어 이용자의 상위 즐겨찾기 5개를, 혹은 즐겨찾기가 없다면  추천정보를 UI에 노출하는 코드를 생각해볼때, 각 경우의 수를 나누어 콜백 함수를 호출하고 이 결과값을 리스트에 전달한다. 양이 많고 어렵고 반복되는 부분이 많다.  이 코드를 리액터로 바꿀 수 있다. 


Future 객체는 콜백보다 여러면에서 더 낫고 8버전에서는 CompletableFuture로 좀 더 개선되기도 했지만, 조합해서 사용하긴 여전히 어렵다. Future 객체 여러개를 조율하기란 가능은 하지만 쉽지는 않다. 
 - 퓨처 객체는 겟 매소드를 호출하면 결국 블로킹 된다.
 - 지연연산을 지원하지 않는다. 
 - 멀티밸류에 대한 지원이 부족하며, 에러처리를 커스텀하기 힘들다.

이름과 통계정보를 상으로 조회하고 싶은 데이터의 ID 리스트를 가져오고, 모든 동작을 비동기로 처리한다고 생각해보자. 

## 3.3 From Imperative to Reactive Programming
 리액터 같은 리액티브 라이브러리의 목적은 JVM의 고전적인 비동기 접근법의 문제를 해결하는 것이며, 다음과 같은 특징이 있다.

 - 쉽게 쓰고 가독성이 높음
 - 데이터는 풍부한 연산자로 조작할 수 있는 플로우로 표현한다. 
 - 구독하기 전까지 아무 일도 일어나지 않는다.
 - Backpressure 즉 컨슈머가 프로듀서에 데엍 생산속도가 너무 빠르다는 신호를 보낼 수 있다.
 - 고수준이면서도 동시성에 구애받지 않늘 정도의 높은 수준으로 추상화한다.
