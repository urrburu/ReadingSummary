마이크로소프트가 닷넷 생태계에 만든 Reactive Extension 라이브러리가 반응형 프로그래밍의 출발점이었다. 이후 Rxjava는 JVM위에서 실행하는 리액티브 프로그래밍을 구현했다. 시간이 지남에 따라, 리액티브 스트림 표준화의 일환으로 JVM 위에서 동작하는 리액티브 라이브러리의 인터페이스 셋과 상호작용 규칙을 정의한 자바 표준이 등장했다. 이 인터페이스들은 자바9의 Flow 클래스로 통합되었다. 

리액티브 프로그래밍 패러다임은 객체 지향 언어에서 종종 옵저버 디자인 패턴의 확장으로 사용되기도 한다. 메인 리액티브 스트림 패턴을 익숙한 이터레이터 디자인 패턴과 비교해 볼 수도 있다. 리액티브 스트림을 구현한 모든 라이브러리는 Iterable-Iterator 쌍과 성격이 유사하다. 주요 차이점 중 하나는 하나는 이터레이터는 pull기반, 리액티브 스트림은 push기반이라는 것이다. 

 이터레이터를 사용한다는 것은 값에 접근하는건 전적으로 Iterable 책임이라고 하지만, 어쨌든 명령형 프로그래밍 패턴이다. 사실상 데이터 시퀀스에서 next() 아이템에 접근하는 것은 개발자에게 달려 있다. 
  리액티브 스트림에선 Publisher - Subscriber 쌍이 이를 대신한다. 또한 push 받은 데이터에 적용할 연산은 명령형이 아닌 선언형으로 표현한다. 프로그래머는 정확한 제어 흐름을 작성하는 대신 계산 논리를 표현한다.

 리액티브 스트림은 데이터를 push 하는 것 외에 에러 처리와 완료 처리도 잘 정의하고 있다. Publisher는 Subscriber에 새 값을 푸쉬할 수 있을 뿐 아니라 에러나 완료신호를 보낼 수도 있다. 에러, 완료 신호 모두 시퀀스를 종료한다. 
```
onNext x 0..N [onError|onComplete]
```
이런 방식이다.

이 접근법은 굉장히 유용하다. 값이 없거나, 하나거나, n개일 때를 모두 커버한다.

## 3.1 블록킹은 낭비가 많을 수 있다.
소프트 웨어의 성능을 끌어올리는 방법은 크게 두가지가 있다. 

 - 더 많은 스레드와 하드웨어 리소스를 사용해 병렬처리한다.
 - 현재 사용중인 리소스를 더 효율적으로 사용할 방법을 찾는다. 

자바 개발자는 보통 블로킹 코드로 프로그램을 작성한다. 성능에 병목이 생기지 않는다면 이 방법도 괜찮다. 이때까진 유사한 블로킹 코드를 실행할 스레드를 늘리면 된다. 하지만 이 방식은 리소스를 더 사용하는 쪽으로 확장하기 때문에, 레이스 컨디션이 발생하고 동시성 이슈가 발생하기 쉽다.

더 큰 문제는 블로킹은 리소스를 낭비한다는 점이다. 자세히 관찰해보면, 대기 시간이 필요한 요청을 처리하기 시작하면 스레드는 데이터를 기다리는 동안 아무 일도 하지 않는다. 
 따라서 병렬처리는 만능 해결책이 아니다. 가능한 하드웨어 리소스를 모두 사용하는게 좋지만 리소스를 낭비하는 경우는 많으며 원인을 알아내는 것은 복잡한 일이다. 
 
## 3.2 비동기가 우리에게 구원인가?
위에서 언급한 두 번째 방식대로, 리소스 효율적으로 사용할 방법을 찾는다면 리소스를 낭비하지 않을 수 있다. 비동기, 논 블로킹 코드를 작성하면 동일 리소스를 사용하는 또 하나의 활성 태스크로 실행을 전환하고, 비동기 처리를 완료하면 현재 프로세스로 돌아올 수 있다. 

 그렇다면 JVM 위에서 동작하는 비동기 코드는 두가지 방법이 있다. 자바가 지원하는 방법은


 - Callbacks : 리턴 값은 없지만 결과를 받으면 호출할 콜백 파라미터를 람다나 익명 클래스로 추가로 받는 비동기 매소드. 스윙의 EventListener 계층 구조로 잘 알려져 있다.
 - Futures 곧바로 Future<T> 를 반환하는 비동기 매소드. 비동기 프로세스는 T값을 계산하고, 이를 래핑한 Future 객체로 접근한다. 이 값은 즉시 사용할 수 있는 상태는 아니며, 사용이 가능해질 때까지 객체를 폴링할 수 있다. 예를 들어 ExecutorService 는 Callable<T> 태스크를 실행할 때 Future 객체를 사용한다. 

두 가지 방법 모두 제약이 있다. 

콜백은 조합이 까다로워 읽기도 유지보수 하기도 어려운 코드를 만드어내기 쉽다. 소위 콜백지옥이라고 이를 부른다. 
예를 들어 이용자의 상위 즐겨찾기 5개를, 혹은 즐겨찾기가 없다면  추천정보를 UI에 노출하는 코드를 생각해볼때, 각 경우의 수를 나누어 콜백 함수를 호출하고 이 결과값을 리스트에 전달한다. 양이 많고 어렵고 반복되는 부분이 많다.  이 코드를 리액터로 바꿀 수 있다. 


Future 객체는 콜백보다 여러면에서 더 낫고 8버전에서는 CompletableFuture로 좀 더 개선되기도 했지만, 조합해서 사용하긴 여전히 어렵다. Future 객체 여러개를 조율하기란 가능은 하지만 쉽지는 않다. 
 - 퓨처 객체는 겟 매소드를 호출하면 결국 블로킹 된다.
 - 지연연산을 지원하지 않는다. 
 - 멀티밸류에 대한 지원이 부족하며, 에러처리를 커스텀하기 힘들다.

이름과 통계정보를 상으로 조회하고 싶은 데이터의 ID 리스트를 가져오고, 모든 동작을 비동기로 처리한다고 생각해보자. 

## 3.3 From Imperative to Reactive Programming
 리액터 같은 리액티브 라이브러리의 목적은 JVM의 고전적인 비동기 접근법의 문제를 해결하는 것이며, 다음과 같은 특징이 있다.

 - 쉽게 쓰고 가독성이 높음
 - 데이터는 풍부한 연산자로 조작할 수 있는 플로우로 표현한다. 
 - 구독하기 전까지 아무 일도 일어나지 않는다.
 - Backpressure 즉 컨슈머가 프로듀서에 데엍 생산속도가 너무 빠르다는 신호를 보낼 수 있다.
 - 고수준이면서도 동시성에 구애받지 않늘 정도의 높은 수준으로 추상화한다.

### 3.3.1 Composability and Readability

 쉽게 구성할 수 있다는 것은 여러 비동기 태스크를 조율할 수 있다는 것이다. 이전 태스크의 결과는 다음 태스크의 입력으로 사용한다. 또는 포크- 조인 스타일로 여러 태스크를 실행할 수도 있다. 추가로 고수준 시스템에선 비동기 태스크를 별개의 컴포넌트로 재사용할 수 있다. 

 여러 태스크를 조율하는 응력은 코드 가독성과 유지보수성에 직결된다. 비동기 처리 레이어가 늘어나고 복잡해지면서 코드를 구성하고 읽기가 점점 더 어려워지고 있다. 처리가 힘들어지면 언급한 바와 같은 콜백지옥이 열린다. 짐작할 수 있듯 이런 코드는 흐름을 따라가 무언가를 추론해내기가 매우 어렵다. 

 리액터는 추상적인 처리 흐름을 반영할 수 있는 풍부한 구성 옵션을 제공하며 이를 사용하면 코드를 최대한 동일레벨로 유지할 수 있다.

### 3.3.2 The Assembly Line Analogy

리액티브 어플리케이션에서 처리하는 데이터는 공장 조립 라인을 통해 이동한다고 생각해 볼 수 있다. 리액터는 거기에서 컨베이어벨트이자 워크스테이션이다. 공급원이 제공한 원료를 소비자에게 전달할 수 있는 완제품으로 만든다.
원료는 변형 등의 중간 단계 여럿을 거칠 수 있고, 중간 단계 재료를 모으는 더 큰 조립 라인의 일부일 수도 있다. 중간에 결함이 생기거나 막히면 문제가 있는 워크 스테이션이 신호를 거슬러 보내 원료 흐름을 제한할 수 있다. 

### 3.3.3 Operators

리액터에서 연산자는 조립 라인으로 비유하자면 워크 스테이션이다. 각 연산자는 퍼블리셔에 동작을 추가하고 이전 단계의 퍼블리셔를 새 인스턴스로 래핑한다. 따라서 전체 체인이 연결되고, 최초 퍼블리셔에서 시작한 데이터를 변환해 다음 체인으로 이동 시킨다. 마지막엔 서브스크라이버가 처리를 종료한다. 곧 언급하겠지만, 서브스크라이버가 퍼블리셔를 구독하기 전까진 아무 일도 일어나지 않는다는 점을 기억하라.

리액티브 스트림 스펙은 연산자를 정의하고 있지 않지만, 리액터 같은 리액티브 라이브러리의 가장 좋은 점 중 하나는 풍부한 연산자를 제공한다는 것이다. 이 연산자로 간단한 변환이나 필터링에서부터 복잡한 조율과 에러 처리까지 할 수 있다.

### 3.3.4 Nothing Happens Until You subscribe()

리액터에서 퍼블리셔 체인을 작성한다고 해서 바로 데이터를 공급하지 않는다. 대신에 비동기 처리를 위한 추상적인 흐름을 작성해야한다. 
구독을 해야 퍼블리셔와 서브스크라이버가 연결되고 전체 체인에 데이터 흐름이 트리거 된다. 내부적으로는 서브스크라이버의 단일 요청 신호가 업스트림으로 전파되어 구독중인 퍼블리셔로 전달된다.

### 3.3.5 Backpressure
백프레셔를 구현할 때도 신호를 업스트림으로 전파한다. 위에서 조립라인에 비유할 때 언급했던, 워크스테이션이 상위 워크 스테이션보다 처리가 느릴 때 피드백으로 보낸다던 신호가 바로 백프레셔다. 
 이 비유는 실제로 리액티브 스트림 스펙에 정의된 매커니즘과 매우 유사하다. 구독자는 언바운드 모드로 데이터 소스로부터 발생하는 모든 데이터를 제일 빠른 속도로 푸시 받거나 리퀘스트 매커니즘으로 최대 n개를 처리할 준비가 되었다는 신호를 보낸다.
중간 연산자로 전송중인 요청을 변경할 수도 있다. 10개의 배치 데이터를 그룹화하는 버퍼연산자를 생각해보자 구독자가 버퍼 하나를 요청하면 데이터 소스는 데이터 10개를 생산할 수 있다. 일부 연산자는 prefetching 전략을 구현하는데 이는 불필요한 request(1) 왕복을 방지하며, 요청 전 미리 데이터를 생성해 두는 비용이 크지 않다면 더 유리하다.

### 3.3.6 Hot vs Cold
리액티브 Rx 라이브러리들은 리액티브 시퀀스를 크게 핫과 콜드로 나눈다. 이는 주로 리액티브 스트림이 구독자에게 반응하는 방식으로 구분한다. 

 - 콜드 시퀀스는 각 서브스크라버만다 데이터 소스를 포함해서 새로 시작한다. 예를 들어 데이터 소스가 Http호출을 래핑하고 있다면 구독할때마다 HTTP요청을 새로 만든다.
 - 핫 시퀀스는 서브스크라이버마다 매번 처음부터 만들지 않는다. 그보단 나중에 구독한 구독자는 구독 이후 생산한 신호를 받는다. 단 일부 핫 리액티브 스트림은 생산 데이터 전체 혹은 일부를 캐시해두거나 이전 데이터를 재사용할 수 있다. 일반적인 관점으로 본다면, 핫 시퀀스는 구독자가 없을 때에도 발생할 수 있다. 이때는 예외적으로 구독하기 전에 아무 일도 일어나지 ㅇ낳는다는 규칙이 적용되지 않는다. 
- 리액터에서의 핫과 콜드 개념에 대해서 더 알 필요가 있다. 추후 상술하도록 하겠다.