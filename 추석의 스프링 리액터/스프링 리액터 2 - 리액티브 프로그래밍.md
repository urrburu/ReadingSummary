마이크로소프트가 닷넷 생태계에 만든 Reactive Extension 라이브러리가 반응형 프로그래밍의 출발점이었다. 이후 Rxjava는 JVM위에서 실행하는 리액티브 프로그래밍을 구현했다. 시간이 지남에 따라, 리액티브 스트림 표준화의 일환으로 JVM 위에서 동작하는 리액티브 라이브러리의 인터페이스 셋과 상호작용 규칙을 정의한 자바 표준이 등장했다. 이 인터페이스들은 자바9의 Flow 클래스로 통합되었다. 

리액티브 프로그래밍 패러다임은 객체 지향 언어에서 종종 옵저버 디자인 패턴의 확장으로 사용되기도 한다. 메인 리액티브 스트림 패턴을 익숙한 이터레이터 디자인 패턴과 비교해 볼 수도 있다. 리액티브 스트림을 구현한 모든 라이브러리는 Iterable-Iterator 쌍과 성격이 유사하다. 주요 차이점 중 하나는 하나는 이터레이터는 pull기반, 리액티브 스트림은 push기반이라는 것이다. 

 이터레이터를 사용한다는 것은 값에 접근하는건 전적으로 Iterable 책임이라고 하지만, 어쨌든 명령형 프로그래밍 패턴이다. 사실상 데이터 시퀀스에서 next() 아이템에 접근하는 것은 개발자에게 달려 있다. 
  리액티브 스트림에선 Publisher - Subscriber 쌍이 이를 대신한다. 또한 push 받은 데이터에 적용할 연산은 명령형이 아닌 선언형으로 표현한다. 프로그래머는 정확한 제어 흐름을 작성하는 대신 계산 논리를 표현한다.

 리액티브 스트림은 데이터를 push 하는 것 외에 에러 처리와 완료 처리도 잘 정의하고 있다. Publisher는 Subscriber에 새 값을 푸쉬할 수 있을 뿐 아니라 에러나 완료신호를 보낼 수도 있다. 에러, 완료 신호 모두 시퀀스를 종료한다. 
```
onNext x 0..N [onError|onComplete]
```
이런 방식이다.

이 접근법은 굉장히 유용하다. 값이 없거나, 하나거나, n개일 때를 모두 커버한다.

## 3.1 블록킹은 낭비가 많을 수 있다.
소프트 웨어의 성능을 끌어올리는 방법은 크게 두가지가 있다. 

 - 더 많은 스레드와 하드웨어 리소스를 사용해 병렬처리한다.
 - 현재 사용중인 리소스를 더 효율적으로 사용할 방법을 찾는다. 

자바 개발자는 보통 블로킹 코드로 프로그램을 작성한다. 

## 3.2 비동기가 우리에게 구원인가?