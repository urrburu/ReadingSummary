1.  한 메서드에 오직 한 단계의 들여쓰기만 한다
2.  else 표현을 사용하지 않는다
3.  모든 원시 값과 문자열을 포장한다
4.  한 줄에 점을 하나만 사용한다
5.  이름을 줄여 쓰지 않는다(축약 금지)
6.  모든 엔티티를 작게 유지한다
7.  3개 이상의 스위프트 기본 데이터타입(Int, String, Double 등) 프로퍼티를 가진 타입을 구현하지 않는다
8.  일급 콜렉션을 사용한다
9.  getter/setter를 구현하지 않는다


라고 하는데..... 킹직히 2번 원칙은 좀 마음에 안들수도.....하지만 그냥 에러를 스로우하거나 객체로 완전히 분리하는 과정이 중요하다고 생각하긴 함.

먼저 1. 한 단계의 인덴트만 해라 -> 결국 내부구조를 복잡하게 설계하지 마라. 직관적인 이름을 써서 별도의 함수나 클래스로 변환해서 사용할 필요가 있다.는 이야기라고 생각함. 
최대한 나열로 해결할 수 있는 방법을 생각해보자. 

2. else 표현 참 많이 쓰는데 쓰지 마라는게, 근데 말이 되긴 한다. 엘스를 쓰게 되면 어떤 조건에서 넘어가는지 정확하게 알기가 힘든 문제점이 있다. 
의외로 스위치-케이스처럼 코딩해 넣을 경우에 이는 큰 문제가 안 될것 같다. 엘스 이프로 조건을 박아둘 수 있으면 비슷하니까. 그런데 그냥 단순 엘스만 처리하고 넘어갈 때가 문제라고 생각함. 결국 예측 못한 경우의 수는 늘어날 건데, 여기에 대해서 적절히 이해하고 대응하기 힘든건 매우 사실
early return 이라는 방법도 있다. 
하지만 1:1로 매핑하는 enum의 방법이 제일 적합하다고 책은 설명한다. 

3. 안티패턴인 Primitive Obsession 을 피하기 위한 노력. 코드 스멜......
### Primitive Obsession

A generalization of [NoStrings](http://wiki.c2.com/?NoStrings):

**The Smell**: Primitive Obsession is using primitive data types to represent domain ideas. For example, we use a String to represent a message, an Integer to represent an amount of money, or a Struct/Dictionary/Hash to represent a specific object.

**The Fix**: Typically, we introduce a [ValueObject](http://wiki.c2.com/?ValueObject) in place of the primitive data, then watch like magic as code from all over the system shows [FeatureEnvySmell](http://wiki.c2.com/?FeatureEnvySmell) and wants to be on the new [ValueObject](http://wiki.c2.com/?ValueObject). We move those methods, and everything becomes right with the world.

When I introduce a [ValueObject](http://wiki.c2.com/?ValueObject), I expect it to become "attractive code", meaning literally a class/module that attracts behavior towards it as new methods/functions. For example, instead of scattering all the parsing/formatting behavior for dates stored as text, introduce a DateFormat class which attracts that behavior as methods called parse() and format(), almost like magic. -- [JbRainsberger](http://wiki.c2.com/?JbRainsberger)

**The Tools**: Some languages make this easier or harder on you. For example, in Ruby, it's easy to start with a String and then upgrade it to a proper Object, since everything is DuckTyped. However, even with its flexibility, it can be a good idea to [AvoidHashySyntaxInRuby](http://wiki.c2.com/?AvoidHashySyntaxInRuby).

4. 한줄에 점 하나만 찍는다.  -> 결국 내부구조를 몰라도 쓸 수 있어야 한다. 는 이야기다. 모든 층위를 쪼개는 것이 중요하다고 계속 이야기한다. 한 층위로만 내부 스코프를 형성하라는 1번 조건, 한 층위로만 변수나 함수들을 구성하라는 4번조건이 결국 일맥상통한다고 본다. 

5. 줄여쓰지 않는다. -> 이건 뭐 대문자만 따서 쓰면 오해의 여지가 아주아주 많으니 당연하다. 



9. 묻지말고 시켜라는 말이 더 적합한 원칙이다. 게터 세터를 쓰지 말라는게 아니라 클래스가 처리해서 넘겨줄 수 있는 값이라면 처리해서 넘겨줄 수 있어야지. 객체의 상태에 기반한 행동은 객체가 스스로 결정할 수 있어야 한다. 이걸 보고 엔티티를 좀 고쳐봐야 겠다리