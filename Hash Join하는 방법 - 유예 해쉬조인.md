빌드입력이 해쉬영역을 초과하면 해쉬 조인은 좀더 복잡한 과정을 거치게 된다. 그 이유는 빌드입력이 해쉬 영역을 초과하게 되면 어쩔 수 없이 디스크를 이용할 수 밖에 없다. 만약 억지로 인메모리 처럼 처리하고자 함ㄴ다면 검색입력이 조인을 시도할 때마다 최악의 경우는 디스크에 있는 것들을 계속해서 메모리로 옮겨야 하기 때문에 도저히 감당할 수 없다. 
 이처럼 빌드입력의 일부라도 디스크에 저장을 할 수 밖에 없다면, 마치 정렬을 통해 연결하는 Sort Merge 조인처럼 무엇인가 정렬과 유사한 효과를 얻을 수 있는 방법이 있어야 한다. 정렬을 하지 않고서도 연결이 가능하도록 데이터를 위치시키는 방법은 바로 해쉬함수를 적용하는 것이다. 
 SOrt Merge 조인은 각각의 집합을 먼저 정렬을 한 수 , 그것을 머지하는 방식으로 연결을 수행한다. 해쉬조인은 각각의 집합에 대해 먼저 해쉬함수를 적용하여 같은 해쉬값을 갖는 파티션에 저장한 후 그들의 짝을 찾아 연결을 수행한다. 
 1) 통계정보를 참조하여 보다 효과적인 카디널리티를 갖는 집합을 빌드입력으로 선택한다. 
 2) 파티션 수를 경정한다
 3) 빌드입력의 조인키에 대하여 1차 해쉬함수를 적용하여 저장할 파티션을 결정한다. 
 4) 2차 해쉬함수를 적용하여 해쉬값을 생성한다.
 5) 이 값을 이용하여 해쉬 테이블을 만들고, 해당 파티션의 슬롯에 저장한다. 이때 저장되는 컬럼은 SQL의 SELECT- List에 있는 컬럼들도 같이 저장된다. 
 6) 검색입력의 필터링을 위해 사용할 비트맵 벡터를 생성한다. 여기서 생성된 겂을 이용해 다름에 수행될 검색입력의 필터링을 하게 되므로 유예 해쉬조인에서도 크기가 작은 비합이 빌드입력이 되는 것이 조인할 대상을 보다 효과적으로 줄일 수 있다. 여기까지는 인-메모리 해쉬 조인과 거의 유사하다. 
 7) 이러한 방식으로 빌드입력의 처리 범위를 처리하다가 해쉬영역을 초과하면 파티션 테이블에 위치정보를 남기고 디스크로 이동하게 된다. 파티션 테이블에 있는 정보는 나중에 파티션 짝을 찾아 연결작업을 수행할 때 사용된다. 
 8)  빌드입력의 모든 처리범위를 위의 방법으로 끝까지 수행한다. 
 9) 이번에는 검색입력의 처리범위를 액세스하기 시작하여 조건을 만족하지 않으면 버리고, 만족한 것들은 1차 해쉬함수를 적용해 비트맵벡터를 필터링한다. 비트맵 벡터에서 찾을 수 없다면 해당 건의 처리는 종료되고 다음 검색입력 대상으로 넘어간다. 
 10) 필터링을 통과한 것은 2차 해쉬함수를 적용한다. 만약 이때 검색입력에 대응되는 빌드입려깅 메모리 내에 존재하면 해쉬 테이블을 읽어 연결을 수행하고 그렇지 않으면 해당 파티션에 저장한다. 
 11)  연결을 수행할 수 없는 파티션들을 디스크에 저장한다. 
 12) 이러한 작업을 검색입력의 모든 처리범위에 대해 반복 수행한다. 
 13) 처리되지 않은 파티션들을 처리하기 위해 파티션 테이블의 정보를 이용하여 파티션 짝들을 디스크에서 메모리로 이동시킨다. 
 14) 새로 메모리로 이동한 집합 중에서 크기가 작은 집합으로 해쉬 테이블을 생성한다. 즉 처리할 파티션 짝들을 모았을 때 그 크기에 따라서 빌드입력과 검색입력이 다시 결정된다. 
 15) 그러므로 경우에 따라서 최초에 결정되었던 빌드입력과 검색입력의 역할이 바뀔 수 있다. 
 16) 검색입력으로 결던된 집합을 스캔하면서 해쉬테이블을 이용하여 연결을 수행한다. 물론 운반단위에 모았다가 채워지면 리턴하는 것은 당연하다. 이 작업을 모든 대상에게 실시한다. 