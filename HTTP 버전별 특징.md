# 1.0
기본적으로 한 연결당 하나의 요청을 처리하도록 설계되어 있음 . TCP의 3-웨이 핸드쉐이크를 계속해서 열어야 하기 때문에 RTT가 증가하는 단점이 있음. 

RTT - 패킷이 목적지에 도달하고 나서 다시 출발지로 돌아오기 까지 걸리는 시간이며 패킷 왕복 시간

매번 연결할 때마다 RTT가 증가하니 서버에 부담이 많이 가고 사용자 응답 시간이 길어졌습니다. 이를 해결하기 위해 이미지 스플리팃, 코드 압축, 베이스 64 인코딩을 사용하곤 했습니다. 

### 이미지 스플리팅

### 코드 압축

### 이미지 Base64 인코딩


# 1.1
매번 TCP연결을 하는 것이 아니라 한번 TCP 초기화를 한 이후 keep-alive라는 옵션으로 여러개의 파일을 송수신할 수 있게 바뀌었음. 1.0에서도 keep-alive 가 있었지만 표준화가 되어있지 않았고 1.1부터 표준화가 되었음.

최초에 3-way Handshaking을 진행하면 그 다음부터 발생하지 않음. 하지만 문서 안에 포함된 다수의 리소스(이미지, css파일, script파일)를 처리하려면 요청할 리소스 개수에 비례해서 대기시간이 길어지는 단점이 있습니다. 

#### HOL Blocking 
네트워크에서 같은 큐에 있는 패킷이 그 첫번째 패킷에 의해 지연될 때 발생하는 성능 저하 현상을 말합니다. 

#### 무거운 헤더구조 
헤더에 쿠키 등 많은 메타데이터가 들어 있고 압축이 되지 않아 무거웠ㅅ브니다. 

# 2.0
SPDY 프로토콜에 의해서 파생된 HTTP/1.x 버전보다 지연시간을 줄이고 응답시간을 더 빠르게 할 수 있으며
멀티플렉싱, 헤더 압축, 서버푸시, 요청의 우선순위를 지원하는 프로토콜입니다. 

#### 멀티 플렉싱 
여러개의 스트림을 사용하여 송수신한다는 것입니다. 이를 통해 특정 스트림의 패킷이 손실되었다고 하더라도 해당 스트림에만 영향을 미치고 나머지 스트림은 동작할 수 있습니다. 

#### 헤더 압축
허프만 코딩 압축 알고리즘을 이용해 1.1의 무거운 헤더를 압축을 사용해 해결했습니다. 

##### 허프만 코딩
문자열을 문자단위로 쪼개 빈도수에 비례하게 빈도가 높으면 적은 비트수를 할애해 표현하는 방법. 

#### 서버 푸시
클라이언트의 요청 없이 서버가 바로 리소스를 푸시할 수 있습니다. 

# 3.0

