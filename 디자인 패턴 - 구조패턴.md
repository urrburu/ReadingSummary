구조패턴이란? 
클래스나 객체를 조합해 더 큰 구조를 만드는 패턴이다. 예를 들어 서로 다른 인터페이스를 지닌 2개의 객체를 묶어 단일 인터페이스를 제공하거나 객체들을 묶어 새로운 기능을 제공하는 패턴이다. 

## 구조패턴 특징

-   서로 독립적으로 개발한 클래스 라이브러리를 마치 하나인 것처럼 사용할 수 있다.
-   여러 인터페이스를 합성하여 서로 다른 인터페이스들의 통일된 추상을 제공한다.
-   인터페이스나 구현을 복합하는 것이 아니라 객체를 합성하는 방법을 제공한다.


## 구조패턴 종류

구조 패턴에는 아래와 같은 디자인 패턴이 존재한다.

### 1.  어댑터 패턴(Adapter Pattern)  
 인터페이스가 호환되지 않는 클래스들을 함께 이용할 수 있도록, 타 클래스의 인터페이스를 기존 인터페이스에 덧씌우는 패턴을 의미한다. 

기존에 존재하는 시스템에 새로운 써드파티 라이브러리가 추가된다든지, 레거시 인터페이스를 새로운 인터페이스로 교체하는 경우, 코드의 재사용성을 높일 수 있는 방법이 어댑터 패턴이다. 

### 2.  브리지 패턴(Bridge Pattern)  
추상화와 구현을 분리해 둘을 각각 따로 발전하도록 만드는 패턴
추상적 개념과 구체적 구현을 서로 다른 두개의 인터페이스로 구현하는 디자인 패턴이다. 
브릿지 패턴은 캡슐화, 집합을 사용하고 또한 다른 클래스 들로 책임을 분리시키기위해 상속을 사용할 수 있다. 

1. 인터페이스와 구현의 분리
2. 독립적 확장 -> 이게 퍼사드와 가장 큰 차이점 퍼사드는 단순한 연결에 방점이 찍힘. 브릿지는 인터페이스와 구현체 각자의 독립적 확장이 가능하게 해준다. 
3. 구현 세부사항을 클라이언트에게 은닉해 캡슐화를 지킬 수 있다. 

-> 대개 리포지토리 개발에서 리포지토리 인터페이스와 그  Impl을 구분하는 방식을 많이 볼 수 있다. 정확히 이 브릿지 패턴에 사용되는 경우가 JPA 리포지토리를 상속받아 인터페이스를 구성하고 그 Impl을 별도로 구현하는 경우이다. 

### 3.  합성 패턴(Composite pattern)  
합성이라는 의미는 혼합, 복합의 의미이다. 
Composite패턴은 용기와 내용물을 동일화 하여 재귀적인 구조를 만드는 방식이다. 

디렉토리와 파일을 함께 디렉토리 항목으로 취급하기 위해 컨테이너와 내용물을 같은 같은 종류의 것으로 취급하는 것이 편리 할 수 있다. 단일 및 집합 객체를 구분하지 않고도 코드 작성이 가능하다. 다만 그렇기에 객체간의 구분, 제약이 힘들다. 

큰 하나의 클래스 타입으로 상속받은 클래스들을 포함하는 방식으로 사용하는 형태를 생각하면 쉽다. 


### 4.  데코레이터 패턴(Decorator Pattern)  
기존내용에 무엇인가를 덧붙인다는 의미가 강하다. 
Decorator 패턴에서는, 장식 테두리(Border)도 내용(StringDisplay)도 공통의 인터페이스를 가지고 있다. 인터페이스는 공통이지만, 감싸면 감을수록 기능이 추가되어 간다. 그 때, 감싸는 쪽을 수정할 필요는 없다. 감싸는 것을 변경하지 않고 기능을 추가 할 수 있다.

객체지향의 특징중 상속을 가장 적극적으로 활용하는 패턴이라고 생각한다. 

특정 클래스를 상속해 만들어진 새로운 클래스에 원하는 부분을 덧붙이는 패턴 

### 5.  퍼사드 패턴(Facade Pattern)  
Facade (외관)는 "건물의 정면"을 의미하는 단어로 어떤 소프트웨어의 다른 커다란 코드 부분에 대하여 간략화된 인터페이스를 제공해주는 디자인 패턴을 의미한다.

퍼사드 객체는 복잡한 소프트웨어 바깥쪽의 코드가 라이브러리의 안쪽 코드에 의존하는 일을 감소시켜 주고 복잡한 소프트웨어를 사용 할 수 있게 간단한 인터페이스를 제공해줍니다.

다른 코드와 소통하는 부분 -> 인터페이스
실질적으로 구현된  ->  복잡한 구현체 

인터페이스만 알아도 다 쓸 수는 있다. 
 - 퍼사드 패턴을 적용하면서 바깥쪽 코드가 라이브러리의 안쪽 코드에 의존하는 현상을 많이 줄여준다. 퍼사드 만으로 두 객체가 서로 소통할 수 있으니까. 
    
### 6.  플라이웨이트 패턴(Flyweight Pattern)  
어떤 클래스의 인스턴스 한 개만 가지고 여러 개의 "가상 인스턴스"를 제공하고 싶을 때 사용하는 패턴이다.  
즉, 인스턴스를 가능한 대로 공유시켜 쓸데없이 new 연산자를 통한 메모리 낭비를 줄이는 방식이다.

주로 생성 된 객체 수를 줄이고 메모리 사용 공간을 줄이며 성능을 향상시키는 데 사용되며, 이러한 유형의 디자인 패턴은 오브젝트 패턴을 감소시켜 어플리케이션에 필요한 오브젝트 구조를 향상시킨다.

-   플라이웨이트 패턴 적용이 적합한 경우

1.  어플리케이션에 의해 생성되는 객체의 수가 많아야 한다.
2.  생성된 객체가 오래도록 메모리에 상주하며 사용되는 횟수가 많다.
3.  객체의 특성을 내적 속성(Intrinsic Properties)과 외적 속성(Extrinsic Properties)으로 나눴을 때, 객체의 외적 특성이 클라이언트 프로그램으로부터 정의되어야 한다.

-   내적 속성과 외적 속성이란?

객체의 내적 속성은 객체를 유니크하게 하는 것이고, 외적 속성은 클라이언트의 코드로부터 설정되어 다른 동작을 수행하도록 사용되는 특성이다. 예를 들어, Circle 이라는 객체는 color와 width라는 외적 속성을 가질 수 있다.
    
### 7.  프록시 패턴(Proxy Pattern)  
-   프록시 패턴이란?

실제 기능을 수행하는 객체(Real Object) 대신 가상의 객체(Proxy Object)를 사용해 로직의 흐름을 제어하는 디자인 패턴이다.

프록시 패턴을 사용하는 경우는 어떤 클래스의 객체 생성이 오래 걸리는 경우 그 일을 분업을 하여 proxy 클래스에서 처리 할 수 있는 부분은 처리를 하고 proxy 클래스에서 처리 할 수 없는 작업에 대해서만 실제 클래스의 객체를 생성하고 위임하는 방식을 취한다.

RealSubject가 원격 시스템에서 돌아가거나 그 객체의 생성 비용이 많이 들어 실제 사용 시점에 객체를 생성하거나 실제 객체에 접근을 제한 및 제어를 해야 할 때 등 의 경우에 사용된다.

-   프록시 패턴 특징

1.  원래 하려던 기능을 수행하며 그외의 부가적인 작업(로깅, 인증, 네트워크 통신 등)을 수행할 수 있다.
    
2.  비용이 많이 드는 연산(DB 쿼리, 대용량 텍스트 파일 등)을 실제로 필요한 시점에 수행할 수 있다.
    
3.  실제 객체의 리소스가 무거운 경우, 프록시 객체에서 간단한 처리를 하거나 기본 객체를 캐싱 처리함으로써 부하를 줄일 수 있다.
    
4.  실제 객체에 대한 수정 없이 클라이언트에서의 사용과 기본 객체 사이에 일련의 로직을 프록시 객체를 통해 넣을 수 있다.
    
5.  프록시는 기본 객체와 요청 사이에 있기 때문에 일종의 방패(보안)의 역할도 한다.
    
6.  사용자 입장에서는 프록시 객체나 실제 객체나 사용법이 유사하므로 구조나 코드 구현이 간단하다.
    

-   프록시 패턴 종류

1.  원격 프록시 : 원격 객체에 대한 접근 제어가 가능하다.
    
2.  가상 프록시 (Virtual Proxy) : 객체의 생성비용이 많이 들어 미리 생성하기 힘든 객체에 대한 접근 및 생성시점 등을 제어한다.
    
3.  보호 프록시 (Protection Proxy) : 객체에 따른 접근 권한을 제어해야하는 객체에 대한 접근을 제어한다.
    
4.  방화벽 프록시 : 일련의 네트워크 자원에 대한 접근을 제어함으로써 주 객체를 '나쁜' 클라이언트들로부터 보호한다.
    
5.  스마트 레퍼런스 프록시 (Smart Reference Proxy) : 주 객체가 참조될 때마다 추가 행동을 제공한다.  
    ex) 객체 참조에 대한 선 작업, 후 작업 등
    
6.  캐싱 프록시 (Caching Proxy) : 비용이 많이 드는 작업의 결과를 임시로 저장 하고, 추후 여러 클라이언트에 저장된 결과를 실제 작업처리 대신 보여주고 자원을 절약한다.
    
7.  동기화 프록시 (Synchronization Proxy) : 여러 스레드에서 주 객체에 접근하는 경우에 안전하게 작업을 처리한다. 주로 분산 환경에서 일련의 객체에 대한 동기화 된 접근을 제어해주는 자바 스페이스에서 사용된다.
    
8.  복잡도 숨김 프록시 (Complexity Hiding Proxy) : 복잡한 클래스들의 집합에 대한 접근을 제어하고, 복잡도를 숨긴다.
    
9.  지연 복사 프록시 (Copy-On-Write Proxy) : 클라이언트에서 필요로 할 때까지 객체가 복사되는 것을 지연시킴으로써 객체의 복사를 제어한다.  
    '변형된 가상 프록시'라고 할 수 있으며, Java 5 의 CopyOnWriteArrayList에서 쓰인다.