## 1부 화폐(돈) 예제

 들어가기 전에 명심할 "테스트 주기"란 
 ```
 1. 작은 테스트를 하나 추가한다
 2. 모든 테스트를 실행해서 테스트가 실패하는 것을 확인한다.
 3. 조금 수정한다.
 4. 모든 테스트를 실행해서 테스트가 성공하는 것을 확인한다.
 5. 중복을 제거하기 위해 리팩토링을 한다.
```
### TDD 법칙 세가지
```
첫째 법칙: 실패하는 단위 테스트를 작성할 때까지 실제 코드를 작성하지 않는다.
둘째 법칙: 컴파일은 실패하지 않으면서 실행이 실패하는 정도로만 단위 테스트틀 작성한다.
셋째 법칙: 현재 실패하는 테스트를 통과할 정도로만 실제 코드를 작성한다.
이런 방식으로 하게 되면, 처음에 로직을 짤 때 특정 케이스를 통과하는 테스트 함수를 먼저 작성하고 이에 대한 로직을 수정하기 때문에 수많은 테스트 함수가 나온다. 짧은 흐름으로 진행하기 때문에 이 하나의 과정은 30초 정도로 묶이게 된다. 문제는, 이 방식을 사용했을 때 나오는 어마무시한 테스트 코드 양이다.
```
F.I.R.S.T.
```
깨끗한 테스트가 따르는 규칙이다.

Fast
테스트는 빨라야 한다. 빠르지 않으면 자주 돌릴 엄두를 못낸다. 코드를 마음껏 정리하기도 어려워진다.

Independent
각 테스트는 서로 의존하면 안된다. 독립적으로 어떠한 순서로 실행해도 괜찮아야 한다. 의존성이 있으면 문제를 파악하기 어려워진다.

Repeatable
어떠한 환경에서도 반복 가능해야 한다. 실제 환경, QA 환경, 네트워크 연결 유무 환경 등에서 모두 실행가능해야 한다. 그렇지 않으면 테스트 코드의 실패 원인을 변명할 거리가 생긴다. 또 환경에 의존적이기 때문에 실행 불가능하다는 단점도 생긴다.

Self-Validating
테스트는 성공 아니면 실패로 결과가 나와야 한다. 테스트가 스스로 성공 여부를 가늠하지 않는다면 판단은 주관적이 되고, 수작업 평가가 필요하게 된다.

Timely
테스트는 적시에 작성되어야 한다. 단위 테스트는 테스트하려는 실제 코드를 구현하기 직전에 구현한다. 만약 반대가 되면, 실제 코드가 테스트하기 너무 어려워 보일 가능성이 크다.
```

### 1장 다중 통화를 지원하는 Money 객체
사용자 입장에서의 시나리오
```Java
	@Test
    void testMultiplication() {
        Dollar five = new Dollar(5);
        five.times(2);
        assertEquals(10, five.amount);
    }
```
우선 컴파일 되게 만들자  ->  실패하는 케이스라도 컴파일이 되도록
```
스텁 구현
메서드의 서명부와 반환 값을 적으며, 이 메서드를 호출하는 코드가 컴파일이 될 수 있도록 껍데기가 만들어 주는 것을 의미한다.
 - 이걸 몰랐다.......
```

테스트를 작성하게 되면 자연스럽게 테스트와 코드 사이에 의존성이 발생하게 된다. 즉 코드나 테스트 중 한쪽을 수정하면 반드시 다른 쪽도 수정해야만 하는 것이다. 의존성이 문제 그 자체라면 중복은 문제의 징후이다. 중복의 가장 흔한 예는 로직의 중복이며, 중복된 로직을 제거하는 가장 좋은 방법은 객체를 이용하는 것이다. 프로그램에서는 중복만 제거해주면 의존성도 제거된다. 이게 TDD의 두번째 규칙이 존재하는 이유이며, 다음 테스트로 진행하기 전에 중복을 제거하여, 오직 한 가지의 코드 수정을 통해 다음 테스트도 통과되게 만들 가능성을 최대화하는 것이다. 

### 2장 타락한 객체
일반적인 TDD의 주기

1. 테스트를 작성한다. 
 - 원하는 입출력을 상상하고 오퍼레이션이 코드에 어떤 식으로 나타나길 원하는 지 생각해볼 것.
2. 실행가능하게 만든다.
 - 깔끔하고 단순한 해법이 보인다면 그것을 채택해라. 아니라면 일단 적어둔 다음 초록막대를 보는 것으로 돌아오자
3. 올바르게 만든다.
 - 이제 시스템이 작동하므로 중복을 제거하고 리팩토링을 하자.

# 결국 목적은 "깔끔한 코드를 얻는 것"
 - 이 확실한 방법이 분할정복(divide and conquer)
 	- 처음부터 '작동하는 깔금한 코드'를 얻을 순 없다.
	- 처음엔 '작동하는'에 해당하는 부분을 먼저 해결하고 나서 '깔끔한 코드' 부분을 해결한다.
	- 이러한 접근 방식은 '깔끔한 코드' 부분을 먼저 해결한 후에, '작동하는' 부분을 해결해 가면서 배운 것들을 설계에 반영하는 '아키텍처 주도 		개발(architecture-driven development)'과 정반대다.

이러한 방식으로 얻을 수 있는 이점
1. 설계상의 결함을 그 결함으로 인해 실패하는 테스트로 변환했다.
2. 스텁 구현으로 빠르게 컴파일을 통과하도록 만들었다.
3. 올바르다고 생각하는 코드를 입력하여 테스트를 통과했다.

### 3장 모두를 위한 평등


### 4장 프라이버시

### 5장 솔직히 말하자면

### 6장 돌아온 ‘모두를 위한 평등’

### 7장 사과와 오렌지

### 8장 객체 만들기

### 9장 우리가 사는 시간(times)

### 10장 흥미로운 시간
### 11장 모든 악의 근원
### 12장 드디어, 더하기
### 13장 진짜로 만들기
### 14장 바꾸기
### 15장 서로 다른 통화끼리 더하기
### 16장 드디어, 추상화
### 17장 Money 회고

2부 XUnit 예시

18장 xUnit으로 가는 첫걸음
19장 테이블 차리기
20장 뒷정리하기
21장 셈하기
22장 실패 처리하기
23장 얼마나 달콤한지
24장 xUnit 회고

3부 테스트 주도 개발의 패턴

25장 테스트 주도 개발 패턴
26장 빨간 막대 패턴
27장 테스팅 패턴
28장 초록 막대 패턴
29장 xUnit 패턴
30장 디자인 패턴
31장 리팩토링
32장 TDD 마스터하기