## TCP

TCP는 신뢰성을 얻기 위한 프로토콜로 OSI계층 중 4계층에 해당하는 연결방식이다. 
3웨이 핸드쉐이크로 연결을 하고 4웨이 핸드쉐이크로 연결을 해제한다. 

### 1) 연결설정
Three Way Handshake  
  
 1-1) 상대에게 통신을 하고 싶다는 메시지를 보낸다. (SYN)  
 1-2) 상대는 그 메시지에 대한 응답 + 나도 통신 준비가 되었다는 메시지를 보낸다. (SYN-ACK)  
 1-3) 2번에서 받은 메시지에 응답을 보낸다. (ACK)  
  
이와 같은 과정을 통해 나와 상대가 통신준비를 마쳤고, 현재 통신이 연결되어 있음을 보장하게 된다. 기존의 회선교환 방식과 유사하지만 단순히 서로 연결되어 있다는 것만 보장한다.

2) 신뢰성 보장과 흐름제어

연결설정을 통해 통신준비를 마치면 이제 서로 데이터를 주고받을 수 있다. 다만 네트워크를 통해서 한 번에 보낼 수 있는 데이터의 양은 제한이 되어 있으므로 분할해서 보내야 된다. 간단히 비유하면 책 한 권 내용을 보내줘야 되는데 이것을 통째로 전송할 수 없으므로 한 장씩 보내는 것으로 생각하면 쉽다. 따라서 분할된 데이터에는 고유번호가 부여되는데 이는 책의 쪽 번호와 같다고 생각하면 된다. 이를 바탕으로 보내는 사람은 현재 몇 쪽을 보낸 것인지 상대에게 알려줄 수 있고, 받는 사람은 다음에 받을 자료가 몇 쪽인지를 알고 보내는 사람에게 요청할 수 있게 된다.  
  
이를 통해 데이터가 제대로 전달됐는지도 알 수 있다. 예를 들어 31쪽을 받을 차례인데 31쪽이 안 오고 다른 데이터가 도착한다면 보내줄 때까지 "31쪽을 보내주세요" 요청하도록 TCP가 설계되어 있다. 그러면 보내는 사람은 상대가 요청한 31쪽을 보내주게 된다. 더불어 31쪽을 보낼 때 알람을 설정하게 되어있는데, 만약 이 알람이 울릴 때까지 받는 사람이 32쪽을 달라고 하지 않으면 역시 데이터가 누락된 것으로 추측할 수 있다. 이를 근거로 보내는 사람은 31쪽을 다시 전송할 수 있다.  
  
여기까지 언급된 것만 보면 컴퓨터끼리 통신을 할 때 마치 데이터 하나씩만 전달하는 것처럼 보일 수 있다. 물론 그렇게 통신한다고 해서 문제가 되는 것은 아니나 당연히 상대가 많이 받을 수 있다면 많이 보내주는 것이 효율적이다. 하지만 무턱대고 보낼 수 있는 것도 아니다. 상대가 5쪽만 받을 수 있는데 보내는 쪽에서 닥치고 10쪽씩 보내버리면 어차피 5쪽은 못 받고 누락되는 것은 마찬가지이다. 따라서 받는 쪽에서 "나 32쪽 받아야 됨. 근데 나 지금 6쪽만큼 받을 수 있음"이라 알려주면 보내는 쪽에서 32쪽에서 37쪽까지 자료를 보내주는 방식으로 동작한다.  
  
이를 위한 TCP의 헤더파일을 살펴보면 목적지주소, 확인응답, 오류검출및복원, 실제데이터 등이 포함되는데 [UDP](https://namu.wiki/w/UDP "UDP")와 구분되는 것이 확인응답(Acknowledge)파일이다. 이것으로 송수신 시 계속 확인응답을 보내어 잘 갔는지, 잘 왔는지 확인을 하여 데이터 신뢰도가 높다. 하지만 데이터 용량이 증가하여 수신속도가 떨어진다는 단점이 따라오게 된다. 물론 그 단점보다는 신뢰성이 높다는 장점이 훨씬 크기 때문에 무시된다.

3) 혼잡제어

사실 초기 TCP에서는 없던 요소이다. 한정된 네트워크 대역폭에서 소수의 사람들이 쓸 때는 몰랐는데 사용자가 점점 늘어나다 보니 네트워크 회선이 그 부하를 감당하지 못하고 사망하는 일이 발생하였다. 여기서 말하는 사망이란, 송신해야 할 책의 낱장이 중간에 있는 네트워크 기기(라우터 등)에 무한히 몰리게 되는 상황을 말한다. 즉, 중간 네트워크 기기가 송신하는 낱장의 속도가 그 기기가 수신하는 속도보다 느리게 되면 이러한 상황이 발생한다. 독이 깨져있어서 물이 새는데 물이 새는 속도보다 더 빨리 물을 채운다면 독이 넘치게 할 수 있는 것과 같다.  
  
이 상황에서 기존 TCP는 위에서 언급했던 방식대로 동작한다고 생각해보자. 그러면 다음과 같은 일들이 발생한다.  
  
송신자 A: '이상하네, 벌써 31쪽을 보낸 지 한참 됐는데 왜 받았다는 연락이 안 올까. 한 번 더 보내야겠다!'  
송신자 B: '이상하네, 벌써 31쪽을 보낸 지 한참 됐는데 왜 받았다는 연락이 안 올까. 한 번 더 보내야겠다!'  
송신자 C: '이상하네, 벌써 31쪽을 보낸 지 한참 됐는데 왜 받았다는 연락이 안 올까. 한 번 더 보내야겠다!'  
  
여기서 A, B, C는 라우터로 송신하는 (독에 물을 붓는) 사람들이다. 이미 라우터에는 아직 라우터가 미처 다 송신하지 못한 A, B, C의 낱장들이 남아 있다. 그런데 A, B, C가 각각 낱장을 또 보낸다. 이것은 두 가지 문제가 있다.  
  
1, 라우터의 저장에도 한계 용량이 있다. 독의 크기가 유한하기 때문에 물을 너무 많이 부으면 넘친다. 그 넘친 물은 다시 독으로 들어오지 않듯, 그렇게 라우터 내의 저장 공간에 저장되지 못한 낱장들은 손실된다.  
  
2. 흐름 제어의 예시에서 보듯, 31쪽을 보냈는데 답신이 없으면 또 31쪽을 보낸다. 만약 라우터가 무한한 저장공간을 가진다는 비현실적인 가정을 하더라도, 결국 라우터에 쌓여가는 낱장들 때문에 32쪽을 보낼 때까지 31쪽을 비정상적으로 많이 보내야 한다. 이는 비효율적이다. 심지어 그러한 가정도 없다면, 보내지는 낱장들은 그저 종이의 낭비이다. (전문용어를 쓰자면, 버려지는 패킷을 위해 전력을 사용했으니, 그 전력이 낭비라는 것이다.)  
  
이러한 문제로 말미암아, 1980년대에 이를 제어하기 위한 방법이 추가됐다.  
  
단순한 예로 통신을 시작할 때 일단 보내는 쪽에서 30~35쪽까지 자료를 보내본다. 그래서 상대가 잘 받았으면 이후 보내는 양을 조금씩 늘려보는 방식을 취한다. 그러다가 상대가 데이터를 제대로 받지 못한 것이 확인되면 그 즉시 보내는 양을 확 줄인다. 그리고 다시 슬금슬금 보내는 양을 늘렸다가 또 못 받았으면 줄여버리는 형태로 보내는 양을 조절하게 된다. 보내는 양을 늘리고 줄이는 방법은 AIMD(Additive Increase/Multiplicative Decrease)를 채택하고 있으나 구체적으로 적용되는 방식은 TCP 버전마다 약간씩 차이가 있으므로 자세한 설명은 [이하생략](https://namu.wiki/w/%EC%9D%B4%ED%95%98%EC%83%9D%EB%9E%B5 "이하생략").  
  
이 방법은 버스트(burst)를 줄이기 위한 것이다. 깨진 독에 어떻게 물이 차오르기 시작하는지를 생각해보면 어렵지 않다. 어느 순간에 빠지는 속도보다 들어오는 속도가 커지는 순간이다. 이것을 버스트라고 부르는데, 요점은 버스트가 나지 않으면 물이 차오르기 시작할 일도 없다는 것이고, 버스트가 발생해서 물이 차오르기 시작했다면 일단 물이 다 빠진 다음에 물을 부으면 되겠다는 생각이다. 이를 네트워크 환경에 맞추어 해석하면, 처음에 버스트가 생기지 않을 적절한 양을 보내고, 버스트가 일어나 라우터에 낱장들이 쌓이기 시작하는 것이 의심된다면 일단 라우터에서 그 낱장들이 빠지는 것을 기다린다는 방법이 되는 것이다.  
  
위 방법을 통해 TCP로 통신하는 모든 사용자들이 네트워크 상황에 따라 속도를 조절할 수 있게 되었으며, 많은 사용자들이 동시에 통신을 시도하면 속도에서 손해를 보게 되지만 죽지는 않게 만들었다. 이론적으로 100 Mbps 회선에서 5명의 사람이 동시에 TCP로 통신을 시도하면 초반에는 서로 차이가 있지만 궁극적으로는 100 Mbps 회선을 각각 20 Mbps씩 공평하게 나눠 가지는 효과를 얻게 된다.

4) 기타등등

현존하는 상당수의 네트워크 프로그램은 TCP를 기반으로 통신한다. 그만큼 데이터 신뢰성을 중요시하는 프로그램들이 많다. [이메일](https://namu.wiki/w/%EC%9D%B4%EB%A9%94%EC%9D%BC "이메일")이나 파일전송 같은 경우 데이터 하나가 날아가면 꽤나 골치 아픈 문제가 발생한다. 하지만 TCP에서 제공하는 신뢰성 보장 방법들을 **반드시 사용할 필요는 없다.** 만약 프로그램에서 필요로 하지 않는다면 **구현하는 과정에서 기능을 끌 수 있게 되어 있다.** 물론 그만큼 신뢰성이 떨어지는 상황은 감수해야 된다.  
  
그 외에 TCP 자체가 오히려 비효율적인 경우도 발생한다. 대표적으로 실시간성을 중요시하거나 응답성을 중요시하는 프로그램인데 이를 위해 개발된 것이 바로 [UDP](https://namu.wiki/w/UDP "UDP")이다.  
  
TCP에 쓰이는 흐름 제어 및 신뢰성 제어 알고리즘은 현대에 들어서는 지나치게 구식이고 성능 상으로 비효율적이라는 평을 받고 있어 개발자들이 UDP 소켓에서 더 효율적인 알고리즘으로 TCP의 기능을 구현하려는 시도가 이어지고 있다. UDP 기반의 웹 문서 프로토콜인 QUIC와 [HTTP/3](https://namu.wiki/w/HTTP/3 "HTTP/3"), UDP 기반의 보안 소켓인 [DTLS](https://namu.wiki/w/DTLS "DTLS")가 그 사례다.

## UDP

비연결성 프로토콜로 데이터그램 방식을 채택하고 있다. 실시간 스트리밍 서비스에서 많이 사용한다. 

신뢰성이 보장되지 않기 때문에 UDP로 데이터를 보내면 손실되는 데이터가 발생할 수 있다.하지만 동영상의 경우를 생각할 때 데이터가 왕창 소실됐다면 괴이한 화면이 나올 수도 있지만, 데이터 몇 개 소실되어봤자 전체 화면에서 일부 구역이 제대로 안나오는 수준에 불과하다. 그렇기에 사람들이 크게 불평하지 않을 수준의 영상만 제공할 수 있다면 느린 TCP를 쓸 이유가 없는 셈이다. 그렇기에 실시간 스트리밍을 하는 곳에서 주로 사용한다.