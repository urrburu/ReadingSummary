# 클린코드 읽은 부분 정리
#### 클린코드와 코드 스멜

- 리팩토링의 기준이 되는 지점이  코드 스멜이다. 코드 스멜은 어디서 나는지 정리해보자연, 
	-  단어 단위 
		- 변수명만 보더라도 코드가 이해되는 것이 바람직한 변수명이다. 
		- 나 같은 경우, 피드백 받은 부분에서 카멜케이스가 있었다. 첫 글자를 대문자로 쓰는 것은 좋은 변수명 습관이 아니다. 주로 파스칼케이스로 C++을 하면서 쓰곤 했는데, 이 부분을 앞으로 고쳐봐야 겠다. 
	- 코드 문장 단위
	- 코드 함수 단위
		- 함수는 작아야한다 - 얼마나? 기준은? “줄 수”
		- 반복되는 함수는 줄일 수  있어야 한다 -> 얼마나? 세번 이상 반복될  경우.
				
	-   코드 모듈 단위
		-  클래스 - 클래스의 캡슐화 - 클래스는 작아야한다!
			-  클래스를 만들때 첫번 째 규칙은 크기, 두번째 규칙도 크기이다. 무조건 작아야 한다 .  책임이 하나처럼 보이더라도 세부적인 단위에서 책임은 분리되면 분리될 수록 좋다. 
			-  클래스의 작은 단위를 세는 기준은 “책임” 이다. 
			-  Single Responsibility 원칙!
			- 중요한건 매서드의 수가 아니라 클래스가 갖게되는 책임 단위이다. 
			- 흔한 어플리케이션 디자인에서 표현하자면 Service의 함수들은 하나의 엔티티와 관련된 것으로 책임을 다한다.  Controller의 함수들은 엔티티와 관련된 책임들을 처리하는 것으로 구성된다.   
		-  응집도 (Cohesion)
			-  소공에서 배웠던 부분이었다. 하나의 클래스에 있어서 응집도가 높은 프로그래밍을 우리는 선호한다. 
			- 그게 6~7개 수준으로 구분하는데 , 하나의 클래스가 얼마나 의미단위를 갖고 있는지, 혹은 더 정확하게는 얼마나 **책임**을 지고 있는지 알수 있다.
			- 우연적 응집도 -> 안에 구성요소들 가운데에 아무런 연관관계가 없는 것을 의미한다.
			- 논리적 응집도 -> 비슷한 성격의 요소들을 모아둔 응집도이다.
			- 시간적 응집도 -> 실행 순서가 같은 요소들을 모아둔 응집도이다.
			- 절차적 응집도 -> 모듈이 다수의 관련 기능을 가질 때 모듈 안의 구성요소들이 그 기능을 순차적으로 수행할 경우의 응집도
			- 통신적 응집도 -> 동일한 입력과 출력을 사용하여 다른 기능을 수행하는 활동들이 모여 있을 경우의 응집도
			- 순차적 응집도 -> 모듈 내에서 한 활동으로부터 나온 출력 값을 다른 활동이 사용할 경우의 응집도
			- 기능적 응집도 -> 단 하나의 기능으로 응집되어있는 응집도이다. 
		- 결합도(Coupling)
			- 자료 결합-> 패러미터로 자료형을 공유하는 형태
			- 스탬프 결합 -> 모듈간의 인터페이스로 배열, 객체, 구조체가 공유됨
			- 제어 결합 -> 어떤 모듈이 다른 모듈의 내부 논리 조직을 제어하기 위한 목적으로 제어 신호를 이용하여 통신하는 경우의 결합도
			- 외부 결합 -> 모듈이 다수의 관련 기능을 가질 때 모듈 안의 구성요소들이 그 기능을 순차적으로 수행할 경우의 결합도
			- 공통 결합 -> 파라미터가 아닌 모듈 밖에 선언되어 잇는 전역 변수를 참조하고 전역변수를 갱신하는 방식으로 상호작용하는 결합도
			- 내용 결합 -> 다른 모듈 내부에 있는 변수나 기능을 다른 모듈에서 사용하는 경우의 결합도 매우 안 좋으며 피해야함