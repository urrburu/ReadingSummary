## 아 왜.....
@ManyToMany를 안 쓰는 이유를 왜 순환참조 문제라고 했지.....
일단 결론은 아니다. 

왜 와이?

개발하다보면 연결테이블이 단순히 연결만 하고 끝나지 않는다. 조인 테이블 자체에 주문시간, 수량 같은 추가 데이터가 많이 들어갈 수 있다. 

하지만 매핑정보만 넣는 것이 가능하고 추가정보를 넣는 것 자체가 불가능하다

내 경우라면 account와 Travel이 다대다 관계로 연결되어 있다. 하지만 정확하게 이걸 연결해주기 위해서는 조인 요청 테이블을 새롭게 만들어 줘서 1:다 , 다:1의 관계로 표현하는 것이 적합하다. 

연결 테이블을 엔티티로 승격시키면서 중간에 있는 정보를 저장할 수 있도록 해주는 것이다.


# 순환참조 문제

부정확한 기억이 안 좋은 리드를 이끌고 온 사례......지만, 문제는 항상 고치면 된다! 문제는 고쳐서 강점으로!

Spring Boot는 @ResponseBody를 선언 할시 Object를 json상태로 변환하기 위해 Jackson라이브러리를 이용합니다. Jackson은 직렬화를 이용해서 json 형태로 객체를 변환시키게 된다. 이때 기본적으로 공용 필드에 대해서만 직렬화를 하는데, 비 공용 필드를 직렬화 하기 위해선 비 공용 필드에 대한 게터 매소드가 존재해야 직렬화를 할 수 있다. 

순환참조문제의 원인은 관련된 엔티티를 밑도 끝도 없이 다 긁어오는데 그 원인이 있다. 왜 긁어오냐? 긁어오라고 설정을 했으니까! Account와 Travel을 예로 든다면 Account -> Travel -> Account 이런 식으로 끊기지 않는 참조괸계가 계속된다. 
왜 와이? 

### 순환참조 문제를 해결하는 방법
이 예제는 API 조회를 그 예시로 들고 있다. 

 1. @JsonIgnore 
	JsonIgnore 어노테이션을 붙이게 된다면 해당 엔티티를 그대로 조회하는 중에 관련된 연관관계의 정보를 여기서 끊으라는 설정으로 Spring은 이해하게 된다. 그렇다면 연결된 엔티티 정보를 다 갖고 오지 않을 수 있고! 순환참조의 문제를 끊을 수 있게 된다! ---> 이건 정말 최악의 판단

	엔티티에 프레젠테이션 계층을 위한 로직이 추가된다. 
    엔티티의 모든 값이 노출된다.
 
 	1-1.  @JsonManagedReference와 @JsonBackReference를 사용하는 방법
    - @JsonManagedReference를 Member(부모 클래스, 연관 관계 주인의 반대편, 정상적으로 직렬화 됨), @JsonBackReference를 Post(자식 클래스, 연관 관계의 주인 - 외래 키가 있는 곳, 직렬화 하지 않도록 막음)에 붙이면 된다.
    	
 
 
 2. 로딩할때 LazyLoading
	- Eager 로딩과 Lazy로딩 
	 이거로딩은 로딩할때 관련된 엔티티를 모두 긁어오는 방식, 레이지 로딩은 해당 엔티티를 참조해서 알아야 할때 로딩하는 방식이다. 
     Lazy 로딩을 사용하게 되면 실제 엔티티 대신에 프록시 인스턴스가 존재하게 된다. 
     fetch방식을 모두 Lazy로 바꾸고 성능최적화가 필요한 경우에는 fetch Join을 사용하는 것이 맞다.
		- 지연로딩은 영속성 컨텍스트에서 조회하므로 이미 조회된 경우 쿼리를 생략하긴 한다. 

## 결론
 너무 순환참조는 항상 나에게 어려운 문제라 피해가는걸 좋아했다. 그게 이 사단을 만들었다고 생각한다. 
 M:N을 쓰지 않는 문제와 순환참조 문제를 여기서 되짚어 보았다. 이게 큰 수확이라고 생각한다. 
 뿐만 아니라 순환참조 문제 안에서도 API사용에 관한 문제와 데이터베이스 조회에 관한 문제를 분리시켜 보는 시야를 얻었다. 
 
 ### 요약
 M:N 연관관계를 왜 비즈니스 로직에 쓰지 않나요? 
  - 단순한 연관관계라면 모를까 대부분은 다대다 관계를 맺을때 이와 관련한 정보가 추가로 들어가야 한다고 배웠습니다. 예를 들어 저는 이 부분을 잘못 받고 있지만 회원이 여행에 신청을 한다면 이를 언제 신청했는지, 받아들일 것인지, 언제 받아들였는지, 언제 거절했는지와 같은 정보를 저장해야하지만 M:N 관계에서는 그러지 못하는 한계가 존재합니다.

순환참조는 어떨때 일어나나요? 
JPA에서 양방향으로 연결된 엔티티를 그대로 조회하는 경우 서로의 정보를 순환하면서 조회하다 발생했습니다. 

그렇다면 이 문제는 어떻게 해결하나요?
Eager로딩으로 설정된 부분을 Lazy로딩으로 바꿔줘서 해결할 수 있습니다. 즉시로딩방식이 해당 엔티티를 조회할때 관련 정보를 모두 갖고오는 형태라면 Lazy로딩은 그 부분을 참조할때 해당 정보를 들고오는 형태입니다. 이 방식을 JPA조회에 사용하면 순환참조 문제가 발생하지 않게 됩니다. 

면접중에 계속 DTO이야기를 계속 하셨는데 이 부분은 무엇인가요? 
이는 사실 엔티티 노출과 관계되어있는 이야기입니다. 외부에 엔티티를 그대로 노출하게 엔티티 스펙변경 ->API 스펙변경으로 이어질 수 밖에 없고 이는 관련된 모든 서비스들에 영향을 미치게 됩니다. 안 좋은 방식이란거죠. 그래서 반환할때 DTO에 결과값을 담아 반환하는데, 이는 순환참조와는 관련이 적은 이야기입니다.

DTO를 사용해서 저장소에서 조회할 수 도 있습니다. 이 경우, 이 문제가 잡히지 않는데 잡힌다고 오해했습니다. 
